[
    {
        "name": "Programming as a way of thinking",
        "tags": [
            "programming",
            "computer-science",
            "thinking"
        ],
        "summary": "Introduction to programming as a way of thinking that combines mathematics, engineering, and natural science approaches",
        "content": "The first goal of this book is to teach you how to program in Python.\nBut learning to program means learning a new way to think, so the second goal of this book is to help you think like a computer scientist.\nThis way of thinking combines some of the best features of mathematics, engineering, and natural science.\nLike mathematicians, computer scientists use formal languages to denote ideas -- specifically computations.\nLike engineers, they design things, assembling components into systems and evaluating trade-offs among alternatives.\nLike scientists, they observe the behavior of complex systems, form hypotheses, and test predictions.\n\nWe will start with the most basic elements of programming and work our way up.\nIn this chapter, we'll see how Python represents numbers, letters, and words.\nAnd you'll learn to perform arithmetic operations.\n\nYou will also start to learn the vocabulary of programming, including terms like operator, expression, value, and type.\nThis vocabulary is important -- you will need it to understand the rest of the book, to communicate with other programmers, and to use and understand virtual assistants.",
        "source": "book"
    },
    {
        "name": "Arithmetic Operators",
        "tags": [
            "operators",
            "arithmetic",
            "python-basics"
        ],
        "summary": "Basic arithmetic operators in Python including addition, subtraction, multiplication, division, and exponentiation",
        "content": "An **arithmetic operator** is a symbol that represents an arithmetic computation.\n\n**Basic Operators:**\n- `+` - Addition: `30 + 12` → 42\n- `-` - Subtraction: `43 - 1` → 42\n- `*` - Multiplication: `6 * 7` → 42\n- `/` - Division: `84 / 2` → 42.0\n- `//` - Integer division: `84 // 2` → 42, `85 // 2` → 42\n- `**` - Exponentiation: `7 ** 2` → 49\n\n**Important Notes:**\n- Division (`/`) always returns a floating-point number\n- Integer division (`//`) always rounds down\n- `^` is NOT exponentiation in Python - it's the XOR bitwise operator",
        "source": "book"
    },
    {
        "name": "Expressions and Values",
        "tags": [
            "expressions",
            "values",
            "order-of-operations"
        ],
        "summary": "Understanding expressions, values, and operator precedence in Python",
        "content": "**Expression:** A collection of operators and numbers.\n\n**Value:** The result of evaluating an expression.\n\n**Order of Operations:**\n- Exponentiation happens before multiplication and division\n- Multiplication and division happen before addition and subtraction\n- Parentheses can override the default order\n\n**Examples:**\n- `6 + 6 ** 2` → 42 (exponentiation first)\n- `12 + 5 * 6` → 42 (multiplication before addition)\n- `(12 + 5) * 6` → 102 (parentheses change order)",
        "source": "book"
    },
    {
        "name": "Arithmetic Functions",
        "tags": [
            "functions",
            "built-in-functions",
            "rounding"
        ],
        "summary": "Built-in arithmetic functions in Python including round() and abs()",
        "content": "Python provides built-in functions for common arithmetic operations:\n\n**round()** - Rounds a floating-point number to the nearest integer:\n- `round(42.4)` → 42\n- `round(42.6)` → 43\n\n**abs()** - Computes the absolute value:\n- `abs(42)` → 42\n- `abs(-42)` → 42\n\n**Function Call Syntax:**\n- Parentheses are required when calling functions\n- `abs 42` would cause a SyntaxError\n- Function names without parentheses refer to the function object itself",
        "source": "book"
    },
    {
        "name": "Strings",
        "tags": [
            "strings",
            "text",
            "concatenation"
        ],
        "summary": "Working with strings in Python - creation, concatenation, and basic operations",
        "content": "**Strings** are sequences of characters used to represent text.\n\n**String Creation:**\n- Single quotes: `'Hello'`\n- Double quotes: `\"world\"`\n- Double quotes are useful for strings containing apostrophes: `\"it's a small \"`\n\n**String Operations:**\n- **Concatenation**: `+` joins strings: `'Well, ' + \"it's a small \" + 'world.'`\n- **Repetition**: `*` repeats strings: `'Spam, ' * 4` → `'Spam, Spam, Spam, Spam, '`\n- **Length**: `len()` returns string length: `len('Spam')` → 4\n\n**Important Notes:**\n- Only straight quotes are allowed (not backticks or smart quotes)\n- Other arithmetic operators don't work with strings",
        "source": "book"
    },
    {
        "name": "Values and Types",
        "tags": [
            "types",
            "type-conversion",
            "python-types"
        ],
        "summary": "Understanding data types in Python and type conversion between them",
        "content": "**Basic Data Types:**\n- **int**: Integers - `type(2)` → `<class 'int'>`\n- **float**: Floating-point numbers - `type(42.0)` → `<class 'float'>`\n- **str**: Strings - `type('Hello')` → `<class 'str'>`\n\n**Type Conversion:**\n- `int()` converts to integer (rounds down): `int(42.9)` → 42\n- `float()` converts to float: `float(42)` → 42.0\n- `str()` converts to string\n\n**Important Distinctions:**\n- `'126'` is a string, not a number\n- Strings containing digits must be converted before arithmetic: `int('126') / 3` → 42.0\n- Use underscores for large numbers: `1_000_000` not commas",
        "source": "book"
    },
    {
        "name": "Formal vs Natural Languages",
        "tags": [
            "programming-concepts",
            "languages",
            "theory"
        ],
        "summary": "Differences between formal programming languages and natural human languages",
        "content": "**Natural Languages:** Languages people speak (English, Spanish, French) that evolved naturally.\n\n**Formal Languages:** Languages designed by people for specific applications (mathematics, programming).\n\n**Key Differences:**\n\n1. **Ambiguity:**\n   - Natural languages: Full of ambiguity, resolved with context\n   - Formal languages: Nearly unambiguous, every program has exactly one meaning\n\n2. **Redundancy:**\n   - Natural languages: Verbose with redundancy to reduce misunderstandings\n   - Formal languages: Concise with minimal redundancy\n\n3. **Literalness:**\n   - Natural languages: Use idioms and metaphors\n   - Formal languages: Mean exactly what they say\n\nFormal languages are more dense, structure is important, and details matter significantly.",
        "source": "book"
    },
    {
        "name": "Debugging",
        "tags": [
            "debugging",
            "programming-practice",
            "problem-solving"
        ],
        "summary": "Introduction to debugging and managing emotions during programming",
        "content": "**Bug:** A programming error.\n\n**Debugging:** The process of finding and correcting errors.\n\n**Emotional Aspects:**\n- Programming and debugging can bring out strong emotions (anger, sadness, embarrassment)\n- Being prepared for these reactions helps manage them\n- View the computer as an employee with specific strengths (speed, precision) and weaknesses (no empathy, no big picture)\n\n**Management Approach:**\n- Be a good manager: leverage strengths and mitigate weaknesses\n- Use emotions to engage with problems without letting reactions interfere with work\n- Debugging is a valuable skill applicable beyond programming",
        "source": "book"
    },
    {
        "name": "Variables",
        "tags": [
            "programming",
            "python",
            "basics"
        ],
        "summary": "Variables are names that refer to values, created using assignment statements with the equals operator.",
        "content": "A **variable** is a name that refers to a value. To create a variable, we write an **assignment statement** like:\n\n```python\nn = 17\npi = 3.141592653589793\nmessage = 'And now for something completely different'\n```\n\nAn assignment statement has three parts: the name of the variable on the left, the equals operator (`=`), and an expression on the right. When you run an assignment statement, there is no output. Python creates the variable and gives it a value, but the assignment statement has no visible effect.\n\nAfter creating a variable, you can use it as an expression, as part of an expression with arithmetic operators, or when calling a function.",
        "source": "book"
    },
    {
        "name": "State Diagrams",
        "tags": [
            "programming",
            "python",
            "visualization"
        ],
        "summary": "State diagrams are graphical representations showing variables and the values they refer to.",
        "content": "A common way to represent variables on paper is to write the name with an arrow pointing to its value. This kind of figure is called a **state diagram** because it shows what state each of the variables is in. We use state diagrams throughout the book to represent a model of how Python stores variables and their values.",
        "source": "book"
    },
    {
        "name": "Variable Names",
        "tags": [
            "programming",
            "python",
            "syntax"
        ],
        "summary": "Variable names can contain letters, numbers, and underscores but cannot start with numbers or be Python keywords.",
        "content": "Variable names can be as long as you like. They can contain both letters and numbers, but they can't begin with a number. It is legal to use uppercase letters, but it is conventional to use only lower case for variable names.\n\nThe only punctuation that can appear in a variable name is the underscore character (`_`). It is often used in names with multiple words, such as `your_name` or `airspeed_of_unladen_swallow`.\n\nIf you give a variable an illegal name, you get a syntax error. Keywords are special words used to specify the structure of a program and can't be used as variable names. Python has 36 keywords including `False`, `class`, `finally`, `is`, `return`, `None`, `continue`, `for`, `lambda`, `try`, `True`, `def`, `from`, `nonlocal`, `while`, `and`, `del`, `global`, `not`, `with`, `as`, `elif`, `if`, `or`, `yield`, `assert`, `else`, `import`, `pass`, `break`, `except`, `in`, `raise`.",
        "source": "book"
    },
    {
        "name": "Import Statement",
        "tags": [
            "programming",
            "python",
            "modules"
        ],
        "summary": "The import statement is used to import modules containing variables and functions.",
        "content": "In order to use some Python features, you have to **import** them. For example:\n\n```python\nimport math\n```\n\nA **module** is a collection of variables and functions. The math module provides a variable called `pi` that contains the value of the mathematical constant denoted π. To use a variable in a module, you have to use the **dot operator** (`.`) between the name of the module and the name of the variable.\n\nThe math module also contains functions like `sqrt` which computes square roots and `pow` which raises one number to the power of a second number.",
        "source": "book"
    },
    {
        "name": "Expressions and Statements",
        "tags": [
            "programming",
            "python",
            "syntax"
        ],
        "summary": "Expressions compute values while statements perform actions but have no value.",
        "content": "An **expression** can be a single value (like an integer, floating-point number, or string), a collection of values and operators, or can include variable names and function calls.\n\nA **statement** is a unit of code that has an effect, but no value. For example, an assignment statement creates a variable and gives it a value, but the statement itself has no value. Similarly, an import statement has an effect - it imports a module so we can use the variables and functions it contains - but it has no visible effect.\n\nComputing the value of an expression is called **evaluation**. Running a statement is called **execution**.",
        "source": "book"
    },
    {
        "name": "Print Function",
        "tags": [
            "programming",
            "python",
            "output"
        ],
        "summary": "The print function displays values and can take multiple arguments separated by commas.",
        "content": "When you evaluate an expression, the result is displayed, but if you evaluate more than one expression, only the value of the last one is displayed. To display more than one value, you can use the `print` function.\n\n```python\nprint(n+2)\nprint(n+3)\n```\n\nYou can also use a sequence of expressions separated by commas:\n\n```python\nprint('The value of pi is approximately', math.pi)\n```\n\nThe `print` function puts a space between the values.",
        "source": "book"
    },
    {
        "name": "Arguments",
        "tags": [
            "programming",
            "python",
            "functions"
        ],
        "summary": "Arguments are values provided to functions when called, with different functions accepting different numbers and types of arguments.",
        "content": "When you call a function, the expression in parenthesis is called an **argument**. Some functions take only one argument (like `int`), some take two (like `math.pow`), and some can take additional arguments that are optional.\n\nFor example, `int` can take a second argument that specifies the base of the number:\n\n```python\nint('101', 2)  # Returns 5\n```\n\n`round` also takes an optional second argument, which is the number of decimal places to round off to:\n\n```python\nround(math.pi, 3)  # Returns 3.142\n```\n\nSome functions can take any number of arguments, like `print`. If you provide too many or too few arguments, or an argument with a type the function can't handle, Python raises a `TypeError`.",
        "source": "book"
    },
    {
        "name": "Comments",
        "tags": [
            "programming",
            "python",
            "documentation"
        ],
        "summary": "Comments are notes in code that explain what the program is doing but have no effect on execution.",
        "content": "As programs get bigger and more complicated, they get more difficult to read. **Comments** are notes added to programs to explain in natural language what the program is doing. They start with the `#` symbol.\n\nComments can appear on a line by themselves or at the end of a line:\n\n```python\n# number of seconds in 42:42\nseconds = 42 * 60 + 42\n\nmiles = 10 / 1.61     # 10 kilometers in miles\n```\n\nEverything from the `#` to the end of the line is ignored and has no effect on the execution of the program. Comments are most useful when they document non-obvious features of the code or explain *why* the code does something rather than *what* it does.",
        "source": "book"
    },
    {
        "name": "Debugging",
        "tags": [
            "programming",
            "python",
            "errors"
        ],
        "summary": "Three types of errors can occur in programs: syntax errors, runtime errors, and semantic errors.",
        "content": "Three kinds of errors can occur in a program:\n\n* **Syntax error**: Refers to the structure of a program and the rules about that structure. If there is a syntax error anywhere in your program, Python does not run the program and displays an error message immediately.\n\n* **Runtime error**: If there are no syntax errors, the program can start running. But if something goes wrong, Python displays an error message and stops. This type of error is also called an **exception** because it indicates that something exceptional has happened.\n\n* **Semantic error**: Related to meaning. If there is a semantic error, the program runs without generating error messages, but it does not do what you intended. Identifying semantic errors can be tricky because it requires working backward by looking at the output.",
        "source": "book"
    },
    {
        "name": "Function Definition",
        "tags": [
            "programming",
            "python",
            "functions"
        ],
        "summary": "Function definitions specify the name of a new function and the sequence of statements that run when the function is called.",
        "content": "A **function definition** specifies the name of a new function and the sequence of statements that run when the function is called.\n\n```python\ndef print_lyrics():\n    print(\"I'm a lumberjack, and I'm okay.\")\n    print(\"I sleep all night and I work all day.\")\n```\n\n- `def` is a keyword that indicates this is a function definition\n- The name of the function is `print_lyrics`\n- The empty parentheses indicate this function doesn't take any arguments\n- The first line is called the **header** - the rest is called the **body**\n- The header must end with a colon and the body must be indented (conventionally 4 spaces)\n- Defining a function creates a **function object**",
        "source": "book"
    },
    {
        "name": "Function Parameters",
        "tags": [
            "programming",
            "python",
            "functions"
        ],
        "summary": "Parameters are variables in function definitions that receive values from arguments when the function is called.",
        "content": "Functions can take parameters, which are variables that receive values when the function is called.\n\n```python\ndef print_twice(string):\n    print(string)\n    print(string)\n```\n\nThe variable name in parentheses is a **parameter**. When the function is called, the value of the argument is assigned to the parameter. You can use variables as arguments:\n\n```python\nline = 'Dennis Moore, '\nprint_twice(line)\n```\n\nIn this example, the value of `line` gets assigned to the parameter `string`.",
        "source": "book"
    },
    {
        "name": "Function Calls Within Functions",
        "tags": [
            "programming",
            "python",
            "functions"
        ],
        "summary": "Functions can call other functions, allowing for modular program design and code reuse.",
        "content": "Once you have defined a function, you can use it inside another function. This allows for building complex functionality from simpler components.\n\n```python\ndef repeat(word, n):\n    print(word * n)\n\ndef first_two_lines():\n    repeat(spam, 4)\n    repeat(spam, 4)\n\ndef print_verse():\n    first_two_lines()\n    last_three_lines()\n```\n\nWhen we run `print_verse()`, it calls `first_two_lines()`, which calls `repeat()`, which calls `print()`. This demonstrates how functions can work together to build more complex behavior.",
        "source": "book"
    },
    {
        "name": "For Loops",
        "tags": [
            "programming",
            "python",
            "control-flow"
        ],
        "summary": "For loops allow repeating a block of code a specified number of times using the range function.",
        "content": "A `for` statement is used to repeat a computation. Here's a simple example:\n\n```python\nfor i in range(2):\n    print(i)\n```\n\n- The first line is a header that ends with a colon\n- The second line is the body, which must be indented\n- The header starts with `for`, a variable name (`i`), and `in`\n- `range(2)` creates a sequence of values `[0, 1]`\n- In Python, counting usually starts from `0`\n- When the loop runs, it assigns each value from `range` to `i` and executes the body\n- You can put a `for` loop inside a function\n\nExample with functions:\n\n```python\ndef print_n_verses(n):\n    for i in range(n):\n        print_verse()\n        print()\n```",
        "source": "book"
    },
    {
        "name": "Local Variables and Parameters",
        "tags": [
            "programming",
            "python",
            "scope"
        ],
        "summary": "Variables created inside functions and parameters are local, meaning they only exist within that function.",
        "content": "When you create a variable inside a function, it is **local**, which means that it only exists inside the function.\n\n```python\ndef cat_twice(part1, part2):\n    cat = part1 + part2\n    print_twice(cat)\n```\n\nWhen `cat_twice` runs, it creates a local variable named `cat`, which is destroyed when the function ends. If you try to access it outside the function, you get a `NameError`.\n\nParameters are also local. Outside of a function, there is no access to its parameters.",
        "source": "book"
    },
    {
        "name": "Stack Diagrams",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Stack diagrams show the hierarchy of function calls and the local variables in each function frame.",
        "content": "To keep track of which variables can be used where, it is useful to draw a **stack diagram**. Stack diagrams show:\n\n- The value of each variable\n- The function each variable belongs to\n- The hierarchy of function calls\n\nEach function is represented by a **frame** - a box with the function name on the outside and the parameters and local variables inside.\n\nThe frames are arranged in a stack that indicates which function called which. The bottom frame is `__main__` - a special name for the topmost frame. When you create a variable outside of any function, it belongs to `__main__`.\n\nStack diagrams help visualize the scope of variables and the flow of execution through multiple function calls.",
        "source": "book"
    },
    {
        "name": "Tracebacks",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Tracebacks show the sequence of function calls when an error occurs, helping to identify where the error happened.",
        "content": "When a runtime error occurs in a function, Python displays a **traceback**, which shows:\n\n- The name of the function that was running when the error occurred\n- The name of the function that called it\n- And so on, up the call stack\n\nThe error message includes the traceback, showing the chain of function calls. The function that was running when the error occurred is at the bottom of the traceback.\n\nThe order of functions in the traceback is the same as the order of frames in a stack diagram. Tracebacks are essential for debugging as they help identify exactly where and how an error occurred.",
        "source": "book"
    },
    {
        "name": "Benefits of Functions",
        "tags": [
            "programming",
            "python",
            "software-design"
        ],
        "summary": "Functions provide several benefits including code organization, reusability, and easier debugging.",
        "content": "There are several reasons why dividing programs into functions is valuable:\n\n- **Naming**: Creating functions gives you an opportunity to name groups of statements, making programs easier to read and debug\n- **Code reduction**: Functions can make programs smaller by eliminating repetitive code\n- **Modular debugging**: Dividing long programs into functions allows debugging parts one at a time\n- **Reusability**: Well-designed functions are often useful for many programs\n- **Maintainability**: If you need to make a change, you only have to make it in one place\n\nFunctions are the foundation of programming, enabling modular, maintainable, and reusable code.",
        "source": "book"
    },
    {
        "name": "Debugging Approach",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Debugging is a systematic process of identifying and fixing errors through hypothesis testing and incremental changes.",
        "content": "Debugging can be challenging but is an essential programming skill. Effective debugging approaches include:\n\n- **Detective work**: Using clues to infer what led to the results you see\n- **Experimental science**: Forming hypotheses, modifying code, and testing predictions\n- **Incremental development**: Starting with working code and making small modifications, debugging as you go\n\nIf you find yourself spending too much time debugging, it often means you're writing too much code before testing. Taking smaller steps can lead to faster progress.\n\nDebugging and programming are often intertwined - programming can be seen as gradually debugging a program until it does what you want.",
        "source": "book"
    },
    {
        "name": "Turtle Graphics Module",
        "tags": [
            "programming",
            "python",
            "graphics"
        ],
        "summary": "The jupyturtle module provides functions for creating simple drawings using turtle graphics.",
        "content": "The `jupyturtle` module allows you to create simple drawings by giving instructions to an imaginary turtle. Key functions include:\n\n- `make_turtle()`: Creates a canvas and a turtle for drawing\n- `forward(distance)`: Moves the turtle forward, drawing a line\n- `left(angle)`: Turns the turtle left by the specified angle in degrees\n- `right(angle)`: Turns the turtle right by the specified angle in degrees\n- `penup()`: Lifts the pen so the turtle moves without drawing\n- `pendown()`: Puts the pen down so the turtle draws when moving\n\nYou can import specific functions to avoid using the module prefix:\n\n```python\nfrom jupyturtle import make_turtle, forward, left, right\n```\n\nThe turtle starts facing east (to the right). Moving forward draws line segments, and turning changes the direction.",
        "source": "book"
    },
    {
        "name": "Encapsulation and Generalization",
        "tags": [
            "programming",
            "python",
            "software-design"
        ],
        "summary": "Encapsulation wraps code in functions with names, while generalization replaces specific values with parameters.",
        "content": "**Encapsulation** is the process of wrapping a piece of code in a function. Benefits include:\n\n- Attaching a name to the code as documentation\n- Making code reuse more concise\n- Improving code organization\n\nExample of encapsulation:\n\n```python\ndef square():\n    for i in range(4):\n        forward(50)\n        left(90)\n```\n\n**Generalization** is the process of replacing something specific (like a number) with something general (like a parameter). This makes functions more flexible:\n\n```python\ndef square(length):\n    for i in range(4):\n        forward(length)\n        left(90)\n```\n\nGeneralization allows the function to work with different values, making it more reusable.",
        "source": "book"
    },
    {
        "name": "Function Parameters and Keyword Arguments",
        "tags": [
            "programming",
            "python",
            "functions"
        ],
        "summary": "Functions can take multiple parameters, and keyword arguments make function calls more readable.",
        "content": "Functions can take multiple parameters to increase their flexibility:\n\n```python\ndef polygon(n, length):\n    angle = 360 / n\n    for i in range(n):\n        forward(length)\n        left(angle)\n```\n\nWhen functions have multiple numeric parameters, it can be helpful to use **keyword arguments** (also called named arguments) to make the code more readable:\n\n```python\npolygon(n=7, length=30)\n```\n\nKeyword arguments:\n- Include the parameter names in the argument list\n- Make function calls more self-documenting\n- Can be specified in any order\n- Use the assignment operator `=` to associate arguments with parameters\n\nThis syntax reminds us how arguments and parameters work - when you call a function, the arguments are assigned to the parameters.",
        "source": "book"
    },
    {
        "name": "Refactoring",
        "tags": [
            "programming",
            "python",
            "software-design"
        ],
        "summary": "Refactoring improves code structure without changing its behavior, often by creating more general functions.",
        "content": "**Refactoring** is the process of modifying working code to improve its structure without changing its behavior. This often involves:\n\n- Creating more general functions\n- Eliminating code duplication\n- Improving function interfaces\n\nExample of refactoring:\n\nFirst, create a general `polyline` function:\n\n```python\ndef polyline(n, length, angle):\n    for i in range(n):\n        forward(length)\n        left(angle)\n```\n\nThen rewrite `polygon` to use `polyline`:\n\n```python\ndef polygon(n, length):\n    angle = 360.0 / n\n    polyline(n, length, angle)\n```\n\nAnd create `arc` using `polyline`:\n\n```python\ndef arc(radius, angle):\n    arc_length = 2 * math.pi * radius * angle / 360\n    n = 30\n    length = arc_length / n\n    step_angle = angle / n\n    polyline(n, length, step_angle)\n```\n\nFinally, rewrite `circle` using `arc`:\n\n```python\ndef circle(radius):\n    arc(radius, 360)\n```\n\nRefactoring often happens as you understand a problem better through coding.",
        "source": "book"
    },
    {
        "name": "Development Plan",
        "tags": [
            "programming",
            "python",
            "methodology"
        ],
        "summary": "A systematic approach to program development using encapsulation and generalization.",
        "content": "A **development plan** is a process for writing programs. The \"encapsulation and generalization\" approach involves:\n\n1. **Start small**: Write a small program with no function definitions\n2. **Encapsulate**: Identify coherent pieces and wrap them in functions with descriptive names\n3. **Generalize**: Add parameters to make functions more flexible\n4. **Iterate**: Repeat steps 1-3 until you have a set of working functions\n5. **Refactor**: Look for opportunities to improve by eliminating duplication and creating more general functions\n\nThis approach is useful when you don't know ahead of time how to divide the program into functions, allowing you to design as you go along.",
        "source": "book"
    },
    {
        "name": "Interface and Implementation",
        "tags": [
            "programming",
            "python",
            "software-design"
        ],
        "summary": "Function design has two parts: the interface (how it's used) and implementation (how it works).",
        "content": "The design of a function has two distinct parts:\n\n**Interface**: How the function is used, including:\n- Function name\n- Parameters it takes\n- What the function is supposed to do\n- Return value (if any)\n\n**Implementation**: How the function accomplishes its task, including:\n- The code inside the function\n- Algorithms used\n- Internal variables\n\nExample of different implementations with the same interface:\n\n```python\n# Implementation 1\ndef circle(radius):\n    circumference = 2 * math.pi * radius\n    n = 30\n    length = circumference / n\n    polygon(n, length)\n\n# Implementation 2 (refactored)\ndef circle(radius):\n    arc(radius, 360)\n```\n\nBoth functions have the same interface but different implementations. A good interface should be simple to explain and use.",
        "source": "book"
    },
    {
        "name": "Docstrings",
        "tags": [
            "programming",
            "python",
            "documentation"
        ],
        "summary": "Docstrings are multiline strings at the beginning of functions that document their interface.",
        "content": "A **docstring** is a string at the beginning of a function that explains its interface. Docstrings are typically triple-quoted **multiline strings** that can span multiple lines.\n\nExample:\n\n```python\ndef polyline(n, length, angle):\n    \"\"\"Draws line segments with the given length and angle between them.\n\n    n: integer number of line segments\n    length: length of the line segments\n    angle: angle between segments (in degrees)\n    \"\"\"\n    for i in range(n):\n        forward(length)\n        left(angle)\n```\n\nA good docstring should:\n- Concisely explain what the function does\n- Explain what effect each parameter has\n- Indicate the expected type of each parameter\n- Avoid implementation details\n\nWriting clear docstrings is an important part of interface design. If a function is hard to explain, it might need a better interface.",
        "source": "book"
    },
    {
        "name": "Preconditions and Postconditions",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Preconditions are requirements before a function runs; postconditions are requirements after it finishes.",
        "content": "**Preconditions** are requirements that should be true before a function starts executing. They are the responsibility of the caller.\n\nExample for `polyline`:\n- `n` must be an integer\n- `length` should be a positive number\n- `angle` must be a number (understood to be in degrees)\n\n**Postconditions** are requirements that should be true after the function finishes, including:\n- The intended effect of the function\n- Any side effects\n\nFor debugging:\n- If preconditions are violated and the function fails, the bug is in the caller\n- If preconditions are satisfied but postconditions are not, the bug is in the function\n\nClear preconditions and postconditions form a contract between the function and its caller, helping with debugging and ensuring correct usage.",
        "source": "book"
    },
    {
        "name": "Integer Division and Modulus",
        "tags": [
            "programming",
            "python",
            "operators"
        ],
        "summary": "Integer division (//) divides and rounds down, while modulus (%) returns the remainder of division.",
        "content": "The **integer division** operator, `//`, divides two numbers and rounds down to an integer:\n\n```python\nminutes = 105\nhours = minutes // 60  # Result: 1\n```\n\nThe **modulus operator**, `%`, divides two numbers and returns the remainder:\n\n```python\nremainder = minutes % 60  # Result: 45\n```\n\n**Uses of modulus operator:**\n- Check divisibility: if `x % y == 0`, then `x` is divisible by `y`\n- Extract digits: `x % 10` gives the right-most digit\n- Clock arithmetic: `(11 + 3) % 12` gives `2` (2 PM)\n- Extract last digits: `x % 100` gives the last two digits",
        "source": "book"
    },
    {
        "name": "Boolean Expressions",
        "tags": [
            "programming",
            "python",
            "logic"
        ],
        "summary": "Boolean expressions evaluate to True or False using relational operators like ==, !=, >, <, >=, <=",
        "content": "A **boolean expression** is an expression that evaluates to either `True` or `False`. \n\n**Relational operators:**\n- `==` (equal to)\n- `!=` (not equal to)\n- `>` (greater than)\n- `<` (less than)\n- `>=` (greater than or equal to)\n- `<=` (less than or equal to)\n\nExamples:\n```python\n5 == 5      # True\n5 == 7      # False\nx = 5\nx == 5      # True\n```\n\nImportant: Use `==` for comparison, not `=` (which is for assignment).\n\n`True` and `False` are special values of type `bool`, not strings.",
        "source": "book"
    },
    {
        "name": "Logical Operators",
        "tags": [
            "programming",
            "python",
            "logic"
        ],
        "summary": "Logical operators (and, or, not) combine boolean expressions to form more complex conditions.",
        "content": "**Logical operators** combine boolean values:\n\n- `and`: Both conditions must be true\n- `or`: At least one condition must be true\n- `not`: Negates a boolean expression\n\nExamples:\n```python\nx > 0 and x < 10          # True only if x between 0 and 10\nx % 2 == 0 or x % 3 == 0  # True if x divisible by 2 or 3\nnot x > y                 # True if x > y is False\n```\n\nPython is flexible with logical operators - any nonzero number is interpreted as `True`, but this can be confusing and is best avoided.",
        "source": "book"
    },
    {
        "name": "If Statements",
        "tags": [
            "programming",
            "python",
            "control-flow"
        ],
        "summary": "If statements execute code conditionally based on boolean expressions.",
        "content": "**Conditional statements** allow programs to check conditions and change behavior accordingly.\n\n**Basic if statement:**\n```python\nif x > 0:\n    print('x is positive')\n```\n\n- `if` is a Python keyword\n- The boolean expression after `if` is called the **condition**\n- The indented statements form a **block**\n- If the condition is true, the block executes; if false, it doesn't\n\n**Pass statement:** Used when a block must exist but should do nothing:\n```python\nif x < 0:\n    pass  # TODO: handle negative values\n```",
        "source": "book"
    },
    {
        "name": "Else and Elif Clauses",
        "tags": [
            "programming",
            "python",
            "control-flow"
        ],
        "summary": "Else provides alternative execution when if condition is false; elif provides multiple alternative conditions.",
        "content": "**Else clause:** Provides an alternative when the `if` condition is false:\n```python\nif x % 2 == 0:\n    print('x is even')\nelse:\n    print('x is odd')\n```\n\nThe alternatives are called **branches**.\n\n**Chained conditionals** with `elif` (else if):\n```python\nif x < y:\n    print('x is less than y')\nelif x > y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal')\n```\n\n- No limit on number of `elif` clauses\n- Conditions checked in order\n- Only first true branch executes\n- `else` clause is optional but must be last",
        "source": "book"
    },
    {
        "name": "Nested Conditionals",
        "tags": [
            "programming",
            "python",
            "control-flow"
        ],
        "summary": "Conditional statements can be nested inside other conditionals, but should be avoided when possible.",
        "content": "One conditional can be nested within another:\n```python\nif x == y:\n    print('x and y are equal')\nelse:\n    if x < y:\n        print('x is less than y')\n    else:\n        print('x is greater than y')\n```\n\n**Nested conditionals** can be difficult to read. Logical operators often provide a simpler alternative:\n\nInstead of:\n```python\nif 0 < x:\n    if x < 10:\n        print('x is positive single-digit')\n```\n\nUse:\n```python\nif 0 < x and x < 10:\n    print('x is positive single-digit')\n```\n\nOr more concisely:\n```python\nif 0 < x < 10:\n    print('x is positive single-digit')\n```",
        "source": "book"
    },
    {
        "name": "Recursion",
        "tags": [
            "programming",
            "python",
            "algorithms"
        ],
        "summary": "Recursion occurs when a function calls itself, with a base case to terminate the recursion.",
        "content": "A function that calls itself is **recursive**. Recursion requires:\n- A function that calls itself\n- A **base case** that doesn't make a recursive call\n- Progress toward the base case\n\n**Example - countdown:**\n```python\ndef countdown(n):\n    if n <= 0:\n        print('Blastoff!')\n    else:\n        print(n)\n        countdown(n-1)\n```\n\n**Example - print n times:**\n```python\ndef print_n_times(string, n):\n    if n > 0:\n        print(string)\n        print_n_times(string, n-1)\n```\n\nFor simple cases, `for` loops may be easier, but some problems are naturally recursive.",
        "source": "book"
    },
    {
        "name": "Stack Diagrams for Recursion",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Recursive functions create multiple stack frames, each with its own parameters and local variables.",
        "content": "When a recursive function runs, it creates multiple **stack frames**, each with:\n- The function name\n- Parameters with their current values\n- Local variables\n\nFor `countdown(3)`, the stack would have frames for:\n- `countdown` with `n=3`\n- `countdown` with `n=2`\n- `countdown` with `n=1`\n- `countdown` with `n=0` (base case)\n\nThe frame where `n=0` is the **base case** - it doesn't make a recursive call.\n\nStack diagrams help visualize:\n- The sequence of recursive calls\n- Parameter values at each level\n- When the base case is reached",
        "source": "book"
    },
    {
        "name": "Infinite Recursion",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Infinite recursion occurs when a recursive function never reaches its base case, eventually causing a stack overflow.",
        "content": "**Infinite recursion** occurs when:\n- There is no base case, or\n- The recursion never reaches the base case\n\nExample:\n```python\ndef recurse():\n    recurse()  # No base case - infinite recursion\n```\n\n**Consequences:**\n- Program creates stack frames indefinitely\n- Eventually exceeds Python's recursion limit\n- Causes `RecursionError` (runtime error)\n\n**Prevention:**\n- Ensure every recursive function has a base case\n- Verify the recursion progresses toward the base case\n- Test with various inputs to ensure termination",
        "source": "book"
    },
    {
        "name": "Keyboard Input",
        "tags": [
            "programming",
            "python",
            "io"
        ],
        "summary": "The input() function gets user input as a string, with optional prompt display.",
        "content": "The `input()` function:\n- Stops program execution\n- Waits for user input\n- Returns the input as a string when user presses Enter\n\n**Basic usage:**\n```python\ntext = input()\n```\n\n**With prompt:**\n```python\nname = input('What...is your name?\\n')\n```\n\nThe `\\n` represents a **newline** character, creating a line break.\n\n**Converting input types:**\n```python\nspeed = input('Enter speed: ')\nspeed_int = int(speed)  # Convert to integer\n```\n\nIf conversion fails (e.g., non-numeric input), it causes a `ValueError`.",
        "source": "book"
    },
    {
        "name": "Debugging Techniques",
        "tags": [
            "programming",
            "python",
            "debugging"
        ],
        "summary": "Effective debugging involves reading error messages carefully and understanding where problems actually occur.",
        "content": "**Debugging tips:**\n\n1. **Focus on key information in error messages:**\n   - Error type\n   - Location where error was detected\n\n2. **Syntax errors:**\n   - Often related to invisible characters (spaces/tabs)\n   - Error location may be misleading\n   - Check indentation carefully\n\n3. **Runtime errors:**\n   - Error location indicates where problem was discovered, not necessarily where it occurred\n   - Trace back through the code to find the actual cause\n\n4. **Example debugging scenario:**\n   ```python\n   ratio = numerator // denominator  # Integer division - may cause 0\n   decibels = 10 * math.log10(ratio)  # Error occurs here, but cause is above\n   ```\n\nAlways read error messages carefully but verify the actual problem location.",
        "source": "book"
    },
    {
        "name": "Return Values",
        "tags": [
            "function",
            "return",
            "value"
        ],
        "summary": "Functions can return values that can be assigned to variables or used in expressions, unlike functions that only display output or perform actions.",
        "content": "In previous chapters, we've used built-in functions -- like `abs` and `round` -- and functions in the math module -- like `sqrt` and `pow`. When you call one of these functions, it returns a value you can assign to a variable or use as part of an expression.\n\nThe functions we have written so far are different. Some use the `print` function to display values, and some use turtle functions to draw figures. But they don't return values we assign to variables or use in expressions.\n\nIn this chapter, we'll see how to write functions that return values.",
        "source": "book"
    },
    {
        "name": "Some functions have return values",
        "tags": [
            "return value",
            "function call",
            "expression"
        ],
        "summary": "Functions like math.sqrt return values that can be displayed, assigned to variables, or used in expressions.",
        "content": "When you call a function like `math.sqrt`, the result is called a **return value**. If the function call appears at the end of a cell, Jupyter displays the return value immediately.\n\nIf you assign the return value to a variable, it doesn't get displayed. But you can display it later. Or you can use the return value as part of an expression.\n\nHere's an example of a function that returns a value:\n\n```python\ndef circle_area(radius):\n    area = math.pi * radius**2\n    return area\n```\n\n`circle_area` takes `radius` as a parameter and computes the area of a circle with that radius. The last line is a `return` statement that returns the value of `area`.\n\nWe can assign the return value to a variable, or use it as part of an expression. However, we can't access local variables like `area` from outside the function.",
        "source": "book"
    },
    {
        "name": "And some have None",
        "tags": [
            "None",
            "return",
            "pure function"
        ],
        "summary": "Functions without return statements return None, while pure functions only return values without side effects.",
        "content": "If a function doesn't have a `return` statement, it returns `None`, which is a special value like `True` and `False`. For example, here's the `repeat` function from Chapter 3:\n\n```python\ndef repeat(word, n):\n    print(word * n)\n```\n\nThis function uses the `print` function to display a string, but it does not use a `return` statement to return a value. If we assign the result to a variable, it displays the string anyway, but the variable gets the value `None`.\n\nHere's a function similar to `repeat` except that has a return value:\n\n```python\ndef repeat_string(word, n):\n    return word * n\n```\n\nNotice that we can use an expression in a `return` statement, not just a variable. With this version, we can assign the result to a variable without displaying anything.\n\nA function like this is called a **pure function** because it doesn't display anything or have any other effect -- other than returning a value.",
        "source": "book"
    },
    {
        "name": "Return values and conditionals",
        "tags": [
            "conditional",
            "return",
            "dead code"
        ],
        "summary": "Return statements can be used in conditionals, but all code paths must return a value to avoid None returns.",
        "content": "If Python did not provide `abs`, we could write it like this:\n\n```python\ndef absolute_value(x):\n    if x < 0:\n        return -x\n    else:\n        return x\n```\n\nIf `x` is negative, the first `return` statement returns `-x` and the function ends immediately. Otherwise, the second `return` statement returns `x` and the function ends.\n\nHowever, if you put `return` statements in a conditional, you have to make sure that every possible path through the program hits a `return` statement. For example, here's an incorrect version of `absolute_value`:\n\n```python\ndef absolute_value_wrong(x):\n    if x < 0:\n        return -x\n    if x > 0:\n        return x\n```\n\nWhen `x` is `0`, neither condition is true, and the function ends without hitting a `return` statement, which means that the return value is `None`.\n\nAs another example, here's a version of `absolute_value` with an extra `return` statement at the end:\n\n```python\ndef absolute_value_extra_return(x):\n    if x < 0:\n        return -x\n    else:\n        return x\n\n    return 'This is dead code'\n```\n\nIf `x` is negative, the first `return` statement runs and the function ends. Otherwise the second `return` statement runs and the function ends. Either way, we never get to the third `return` statement -- so it can never run.\n\nCode that can never run is called **dead code**. In general, dead code doesn't do any harm, but it often indicates a misunderstanding, and it might be confusing to someone trying to understand the program.",
        "source": "book"
    },
    {
        "name": "Incremental development",
        "tags": [
            "development",
            "debugging",
            "scaffolding"
        ],
        "summary": "Incremental development involves adding and testing small amounts of code at a time, using temporary variables and print statements for debugging.",
        "content": "As you write larger functions, you might find yourself spending more time debugging. To deal with increasingly complex programs, you might want to try **incremental development**, which is a way of adding and testing only a small amount of code at a time.\n\nAs an example, suppose you want to find the distance between two points represented by the coordinates $(x_1, y_1)$ and $(x_2, y_2)$. By the Pythagorean theorem, the distance is:\n\n$$\\mathrm{distance} = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$$\n\nThe first step is to consider what a `distance` function should look like in Python -- that is, what are the inputs (parameters) and what is the output (return value)?\n\nFor this function, the inputs are the coordinates of the points. The return value is the distance. Immediately you can write an outline of the function:\n\n```python\ndef distance(x1, y1, x2, y2):\n    return 0.0\n```\n\nThis version doesn't compute distances yet -- it always returns zero. But it is a complete function with a return value, which means that you can test it before you make it more complicated.\n\nThe process continues by adding small pieces of code and testing each one:\n\n1. Compute differences `dx` and `dy` and display them\n2. Compute the sum of squares `dsquared` and display it\n3. Compute the square root and display it\n4. Replace the `print` statement with a `return` statement\n\nThe `print` statements we wrote are useful for debugging, but once the function is working, we can remove them. Code like that is called **scaffolding** because it is helpful for building the program but is not part of the final product.\n\nThe key aspects of incremental development are:\n\n1. Start with a working program, make small changes, and test after every change.\n2. Use variables to hold intermediate values so you can display and check them.\n3. Once the program is working, remove the scaffolding.\n\nAt any point, if there is an error, you should have a good idea where it is. Incremental development can save you a lot of debugging time.",
        "source": "book"
    },
    {
        "name": "Boolean functions",
        "tags": [
            "boolean",
            "function",
            "conditional"
        ],
        "summary": "Functions can return boolean values True and False, often used to encapsulate complex tests.",
        "content": "Functions can return the boolean values `True` and `False`, which is often convenient for encapsulating a complex test in a function. For example, `is_divisible` checks whether `x` is divisible by `y` with no remainder.\n\n```python\ndef is_divisible(x, y):\n    if x % y == 0:\n        return True\n    else:\n        return False\n```\n\nInside the function, the result of the `==` operator is a boolean, so we can write the function more concisely by returning it directly.\n\n```python\ndef is_divisible(x, y):\n    return x % y == 0\n```\n\nBoolean functions are often used in conditional statements. It might be tempting to write something like:\n\n```python\nif is_divisible(6, 2) == True:\n    print('divisible')\n```\n\nBut the comparison is unnecessary.",
        "source": "book"
    },
    {
        "name": "Recursion with return values",
        "tags": [
            "recursion",
            "factorial",
            "Turing complete"
        ],
        "summary": "Recursive functions with return values enable Turing completeness, allowing computation of any algorithm.",
        "content": "Now that we can write functions with return values, we can write recursive functions with return values, and with that capability, we have passed an important threshold -- the subset of Python we have is now **Turing complete**, which means that we can perform any computation that can be described by an algorithm.\n\nTo demonstrate recursion with return values, we'll evaluate a few recursively defined mathematical functions. A recursive definition is similar to a circular definition, in the sense that the definition refers to the thing being defined.\n\nFor example, the factorial function has the following recursive definition:\n\n$$\\begin{aligned}\n0! &= 1 \\\\\n n! &= n~(n-1)!\n\\end{aligned}$$\n\nThis definition says that the factorial of $0$ is $1$, and the factorial of any other value, $n$, is $n$ multiplied by the factorial of $n-1$.\n\nIf you can write a recursive definition of something, you can write a Python program to evaluate it. Following an incremental development process, we can implement factorial as:\n\n```python\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        recurse = factorial(n-1)\n        return n * recurse\n```\n\nThe flow of execution for this program involves multiple recursive calls that build up a stack of function calls, with each call waiting for the result of the next call before it can complete its computation.",
        "source": "book"
    },
    {
        "name": "Leap of faith",
        "tags": [
            "recursion",
            "debugging",
            "mental model"
        ],
        "summary": "When reading recursive code, assume recursive calls work correctly rather than tracing every call.",
        "content": "Following the flow of execution is one way to read programs, but it can quickly become overwhelming. An alternative is what I call the \"leap of faith\". When you come to a function call, instead of following the flow of execution, you *assume* that the function works correctly and returns the right result.\n\nIn fact, you are already practicing this leap of faith when you use built-in functions. When you call `abs` or `math.sqrt`, you don't examine the bodies of those functions -- you just assume that they work.\n\nThe same is true when you call one of your own functions. For example, earlier we wrote a function called `is_divisible` that determines whether one number is divisible by another. Once we convince ourselves that this function is correct, we can use it without looking at the body again.\n\nThe same is true of recursive programs. When you get to the recursive call, instead of following the flow of execution, you should assume that the recursive call works and then ask yourself, \"Assuming that I can compute the factorial of $n-1$, can I compute the factorial of $n$?\" The recursive definition of factorial implies that you can, by multiplying by $n$.\n\nOf course, it's a bit strange to assume that the function works correctly when you haven't finished writing it, but that's why it's called a leap of faith!",
        "source": "book"
    },
    {
        "name": "Fibonacci",
        "tags": [
            "recursion",
            "Fibonacci",
            "inefficiency"
        ],
        "summary": "The Fibonacci sequence can be implemented recursively but this approach is inefficient for larger values.",
        "content": "After `factorial`, the most common example of a recursive function is `fibonacci`, which has the following definition:\n\n$$\\begin{aligned}\n\\mathrm{fibonacci}(0) &= 0 \\\\\n\\mathrm{fibonacci}(1) &= 1 \\\\\n\\mathrm{fibonacci}(n) &= \\mathrm{fibonacci}(n-1) + \\mathrm{fibonacci}(n-2)\n\\end{aligned}$$\n\nTranslated into Python, it looks like this:\n\n```python\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    elif  n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```\n\nIf you try to follow the flow of execution here, even for small values of $n$, your head explodes. But according to the leap of faith, if you assume that the two recursive calls work correctly, you can be confident that the last `return` statement is correct.\n\nAs an aside, this way of computing Fibonacci numbers is very inefficient. In Chapter 10 I'll explain why and suggest a way to improve it.",
        "source": "book"
    },
    {
        "name": "Checking types",
        "tags": [
            "type checking",
            "input validation",
            "error handling"
        ],
        "summary": "Input validation using isinstance prevents errors like infinite recursion from incorrect parameter types.",
        "content": "What happens if we call `factorial` and give it `1.5` as an argument? It results in infinite recursion because if `n` is not an integer, we can *miss* the base case and recurse forever.\n\nIn this example, the initial value of `n` is `1.5`. In the first recursive call, the value of `n` is `0.5`. In the next, it is `-0.5`. From there, it gets smaller (more negative), but it will never be `0`.\n\nTo avoid infinite recursion we can use the built-in function `isinstance` to check the type of the argument. Here's how we check whether a value is an integer:\n\n```python\nisinstance(3, int)    # returns True\nisinstance(1.5, int)  # returns False\n```\n\nNow here's a version of `factorial` with error-checking:\n\n```python\ndef factorial(n):\n    if not isinstance(n, int):\n        print('factorial is only defined for integers.')\n        return None\n    elif n < 0:\n        print('factorial is not defined for negative numbers.')\n        return None\n    elif n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n```\n\nFirst it checks whether `n` is an integer. If not, it displays an error message and returns `None`. Then it checks whether `n` is negative. If so, it displays an error message and returns `None`. If we get past both checks, we know that `n` is a non-negative integer, so we can be confident the recursion will terminate.\n\nChecking the parameters of a function to make sure they have the correct types and values is called **input validation**.",
        "source": "book"
    },
    {
        "name": "Debugging",
        "tags": [
            "debugging",
            "scaffolding",
            "print statements"
        ],
        "summary": "Debugging functions involves checking arguments, function logic, and return value usage, using print statements for visibility.",
        "content": "Breaking a large program into smaller functions creates natural checkpoints for debugging. If a function is not working, there are three possibilities to consider:\n\n- There is something wrong with the arguments the function is getting -- that is, a precondition is violated.\n- There is something wrong with the function -- that is, a postcondition is violated.\n- The caller is doing something wrong with the return value.\n\nTo rule out the first possibility, you can add a `print` statement at the beginning of the function that displays the values of the parameters (and maybe their types). Or you can write code that checks the preconditions explicitly.\n\nIf the parameters look good, you can add a `print` statement before each `return` statement and display the return value. If possible, call the function with arguments that make it easy check the result.\n\nIf the function seems to be working, look at the function call to make sure the return value is being used correctly -- or used at all!\n\nAdding `print` statements at the beginning and end of a function can help make the flow of execution more visible. For example, here is a version of `factorial` with print statements:\n\n```python\ndef factorial(n):\n    space = ' ' * (4 * n)\n    print(space, 'factorial', n)\n    if n == 0:\n        print(space, 'returning 1')\n        return 1\n    else:\n        recurse = factorial(n-1)\n        result = n * recurse\n        print(space, 'returning', result)\n        return result\n```\n\n`space` is a string of space characters that controls the indentation of the output. If you are confused about the flow of execution, this kind of output can be helpful. It takes some time to develop effective scaffolding, but a little bit of scaffolding can save a lot of debugging.",
        "source": "book"
    },
    {
        "name": "Iteration and Search",
        "tags": [
            "iteration",
            "search",
            "strings",
            "files"
        ],
        "summary": "Using for loops to iterate through strings and files, and implementing search patterns to analyze text data.",
        "content": "In 1939 Ernest Vincent Wright published a 50,000 word novel called *Gadsby* that does not contain the letter \"e\". Since \"e\" is the most common letter in English, writing even a few words without using it is difficult. To get a sense of how difficult, in this chapter we'll compute the fraction of English words have at least one \"e\".\n\nFor that, we'll use `for` statements to loop through the letters in a string and the words in a file, and we'll update variables in a loop to count the number of words that contain an \"e\". We'll use the `in` operator to check whether a letter appears in a word, and you'll learn a programming pattern called a \"linear search\".",
        "source": "book"
    },
    {
        "name": "Loops and strings",
        "tags": [
            "for loop",
            "loop variable",
            "string iteration"
        ],
        "summary": "Using for loops to iterate through characters in strings and check for specific letters.",
        "content": "We can use a `for` loop to display the letters in a string. The variable defined in a `for` loop is called the **loop variable**. Now that we can loop through the letters in a word, we can check whether it contains the letter \"e\".\n\nWe can encapsulate this logic in a function:\n\n```python\ndef has_e(word):\n    for letter in word:\n        if letter == 'E' or letter == 'e':\n            return True\n    return False\n```\n\nThis function takes a word as a parameter and returns `True` if the word contains an \"e\" and `False` otherwise.",
        "source": "book"
    },
    {
        "name": "Reading the word list",
        "tags": [
            "file handling",
            "file object",
            "methods"
        ],
        "summary": "Working with files using file objects and methods to read and process text data.",
        "content": "To see how many words contain an \"e\", we'll need a word list. The one we'll use is a list of about 114,000 official crosswords; that is, words that are considered valid in crossword puzzles and other word games.\n\nTo read it, we'll use the built-in function `open`, which takes the name of the file as a parameter and returns a **file object** we can use to read the file. The file object provides a function called `readline`, which reads characters from the file until it gets to a newline and returns the result as a string.\n\nThe syntax for calling `readline` is different from functions we've seen so far. That's because it is a **method**, which is a function associated with an object. In this case `readline` is associated with the file object, so we call it using the name of the object, the dot operator, and the name of the method.\n\nTo remove the newline from the end of the word, we can use `strip`, which is a method associated with strings. `strip` removes whitespace characters -- including spaces, tabs, and newlines -- from the beginning and end of the string.\n\nYou can also use a file object as part of a `for` loop to read through all lines in a file.",
        "source": "book"
    },
    {
        "name": "Updating variables",
        "tags": [
            "variables",
            "assignment",
            "update",
            "counter"
        ],
        "summary": "Modifying variable values through assignment and using counters to track occurrences.",
        "content": "It is legal to make more than one assignment to the same variable. A new assignment makes an existing variable refer to a new value (and stop referring to the old value).\n\nA common kind of assignment is an **update**, where the new value of the variable depends on the old. For example: `x = x + 1` means \"get the current value of `x`, add one, and assign the result back to `x`.\"\n\nBefore you can update a variable, you have to **initialize** it, usually with a simple assignment.\n\nIncreasing the value of a variable is called an **increment**; decreasing the value is called a **decrement**. Because these operations are so common, Python provides **augmented assignment operators** that update a variable more concisely. For example, the `+=` operator increments a variable by the given amount.\n\nA variable used to count the number of times something happens is called a **counter**.",
        "source": "book"
    },
    {
        "name": "Looping and counting",
        "tags": [
            "counting",
            "file processing",
            "percentage calculation"
        ],
        "summary": "Using loops and counters to process files and calculate statistics.",
        "content": "We can use counters to count the number of words in the word list and the number of words that contain an \"e\". By comparing these counts, we can calculate what percentage of words use the letter \"e\".\n\nAbout two-thirds of the words use the letter \"e\", which explains why it's difficult to craft a book without using any such words.",
        "source": "book"
    },
    {
        "name": "The in operator",
        "tags": [
            "in operator",
            "string methods",
            "simplification"
        ],
        "summary": "Using the in operator and string methods to simplify search functions.",
        "content": "Python provides an operator, `in`, that checks whether a character appears in a string. So we can rewrite `has_e` more simply:\n\n```python\ndef has_e(word):\n    return 'E' in word or 'e' in word\n```\n\nWe can simplify this function even more using the method `lower`, which converts the letters in a string to lowercase:\n\n```python\ndef has_e(word):\n    return 'e' in word.lower()\n```\n\n`lower` makes a new string -- it does not modify the existing string.",
        "source": "book"
    },
    {
        "name": "Search",
        "tags": [
            "linear search",
            "search pattern",
            "function generalization"
        ],
        "summary": "Implementing linear search pattern to check if elements from one sequence appear in another.",
        "content": "Based on the simpler version of `has_e`, we can write a more general function called `uses_any` that takes a second parameter that is a string of letters. It returns `True` if the word uses any of the letters and `False` otherwise.\n\n```python\ndef uses_any(word, letters):\n    for letter in word.lower():\n        if letter in letters.lower():\n            return True\n    return False\n```\n\nThe structure of `uses_any` is similar to `has_e`. It loops through the letters in `word` and checks them one at a time. If it finds one that appears in `letters`, it returns `True` immediately. If it gets all the way through the loop without finding any, it returns `False`.\n\nThis pattern is called a **linear search**.",
        "source": "book"
    },
    {
        "name": "Doctest",
        "tags": [
            "testing",
            "documentation",
            "doctest"
        ],
        "summary": "Using doctest to create and run tests within function documentation.",
        "content": "It is possible to use a docstring to *test* a function. Here's a version of `uses_any` with a docstring that includes tests:\n\n```python\ndef uses_any(word, letters):\n    \"\"\"Checks if a word uses any of a list of letters.\n\n    >>> uses_any('banana', 'aeiou')\n    True\n    >>> uses_any('apple', 'xyz')\n    False\n    \"\"\"\n    for letter in word.lower():\n        if letter in letters.lower():\n            return True\n    return False\n```\n\nEach test begins with `>>>`, which is used as a prompt in some Python environments to indicate where the user can type code. In a doctest, the prompt is followed by an expression, usually a function call. The following line indicates the value the expression should have if the function works correctly.\n\nTo run these tests, we import the `doctest` module and use `run_docstring_examples`. If all tests pass, no output is displayed. If a test fails, the output includes the example that failed, the value the function was expected to produce, and the value the function actually produced.\n\nIf a test runs and the result is as expected, the test **passes**. If a test runs and the result is not as expected, the test **fails**.",
        "source": "book"
    },
    {
        "name": "Strings and Regular Expressions",
        "tags": [
            "strings",
            "sequences",
            "regular expressions",
            "pattern matching"
        ],
        "summary": "Working with strings as sequences of characters and using regular expressions for advanced pattern matching and text processing.",
        "content": "Strings are not like integers, floats, and booleans. A string is a **sequence**, which means it contains multiple values in a particular order. In this chapter we'll see how to access the values that make up a string, and we'll use functions that process strings.\n\nWe'll also use regular expressions, which are a powerful tool for finding patterns in a string and performing operations like search and replace.",
        "source": "book"
    },
    {
        "name": "A string is a sequence",
        "tags": [
            "indexing",
            "characters",
            "string access"
        ],
        "summary": "Accessing individual characters in strings using indices and understanding zero-based indexing.",
        "content": "A string is a sequence of characters. A **character** can be a letter (in almost any alphabet), a digit, a punctuation mark, or white space.\n\nYou can select a character from a string with the bracket operator. The expression in brackets is an **index**, so called because it *indicates* which character in the sequence to select. The index with value `1` is actually the second letter of the string. An index is an offset from the beginning of the string, so the offset of the first letter is `0`.\n\nYou can think of `'b'` as the 0th letter of `'banana'` -- pronounced \"zero-eth\". The index in brackets can be a variable or an expression that contains variables and operators, but the value of the index has to be an integer.\n\nTo get the last letter of a string, you can use a negative index, which counts backward from the end. The index `-1` selects the last letter, `-2` selects the second to last, and so on.",
        "source": "book"
    },
    {
        "name": "String slices",
        "tags": [
            "slicing",
            "substrings",
            "empty string"
        ],
        "summary": "Extracting portions of strings using slice notation with start and end indices.",
        "content": "A segment of a string is called a **slice**. Selecting a slice is similar to selecting a character. The operator `[n:m]` returns the part of the string from the `n`th character to the `m`th character, including the first but excluding the second.\n\nIf you omit the first index, the slice starts at the beginning of the string. If you omit the second index, the slice goes to the end of the string. If the first index is greater than or equal to the second, the result is an **empty string**, represented by two quotation marks. An empty string contains no characters and has length 0.\n\nUsing `[:]` without indices returns the entire string.",
        "source": "book"
    },
    {
        "name": "Strings are immutable",
        "tags": [
            "immutability",
            "string modification"
        ],
        "summary": "Understanding that strings cannot be modified in place and creating new strings instead.",
        "content": "It is tempting to use the `[]` operator on the left side of an assignment, with the intention of changing a character in a string, but this causes a `TypeError`. The reason for this error is that strings are **immutable**, which means you can't change an existing string. The best you can do is create a new string that is a variation of the original.\n\nFor example, to change the first character of a string, you can concatenate a new first letter onto a slice of the original string. This has no effect on the original string.",
        "source": "book"
    },
    {
        "name": "String comparison",
        "tags": [
            "string comparison",
            "alphabetical order",
            "case sensitivity"
        ],
        "summary": "Comparing strings using relational operators and handling case sensitivity issues.",
        "content": "The relational operators work on strings. To see if two strings are equal, we can use the `==` operator. Other relational operations are useful for putting words in alphabetical order.\n\nPython does not handle uppercase and lowercase letters the same way people do. All the uppercase letters come before all the lowercase letters. To solve this problem, we can convert strings to a standard format, such as all lowercase, before performing the comparison.",
        "source": "book"
    },
    {
        "name": "String methods",
        "tags": [
            "methods",
            "string operations",
            "method invocation"
        ],
        "summary": "Using built-in string methods to perform various operations on strings.",
        "content": "Strings provide methods that perform a variety of useful operations. A method is similar to a function -- it takes arguments and returns a value -- but the syntax is different. For example, the method `upper` takes a string and returns a new string with all uppercase letters.\n\nInstead of the function syntax `upper(word)`, it uses the method syntax `word.upper()`. This use of the dot operator specifies the name of the method and the name of the string to apply the method to. The empty parentheses indicate that this method takes no arguments.\n\nA method call is called an **invocation**; in this case, we would say that we are invoking `upper` on `word`.",
        "source": "book"
    },
    {
        "name": "Writing files",
        "tags": [
            "file handling",
            "file modes",
            "text processing"
        ],
        "summary": "Reading from and writing to files, including filtering content and managing file objects.",
        "content": "String operators and methods are useful for reading and writing text files. To write to a file, we can open it for writing using the mode `'w'`. If the file doesn't exist, it will be created; if it already exists, the contents will be replaced.\n\nWe can use methods like `startswith` and `endswith` to filter lines in a file. The `break` statement \"breaks\" out of the loop -- that is, it causes the loop to end immediately. When we're done with file objects, we should close them using the `close` method.",
        "source": "book"
    },
    {
        "name": "Find and replace",
        "tags": [
            "string search",
            "replacement",
            "count method"
        ],
        "summary": "Searching for text patterns in files and replacing them with new content.",
        "content": "To see whether a line contains a particular sequence, we can use the `in` operator, which checks whether this sequence of characters appears anywhere in the line. To get the total number of times a sequence appears, we can use the `count` method, which returns the number of times a sequence appears in a string.\n\nWe can replace sequences in text using the `replace` method, which creates a new string with all occurrences of a substring replaced with another substring.",
        "source": "book"
    },
    {
        "name": "Regular expressions",
        "tags": [
            "regex",
            "pattern matching",
            "search"
        ],
        "summary": "Using regular expressions for advanced pattern matching and text searching.",
        "content": "If we know exactly what sequence of characters we're looking for, we can use the `in` operator to find it and the `replace` method to replace it. But there is another tool, called a **regular expression** that can also perform these operations -- and a lot more.\n\nA module called `re` provides functions related to regular expressions. We can use the `search` function to check whether a **pattern** appears in the text. If the pattern appears in the text, `search` returns a `Match` object that contains the results of the search.\n\nRegular expressions can do things the `in` operator cannot. For example, if the pattern includes the vertical bar character, `'|'`, it can match either the sequence on the left or the sequence on the right. The special character `'^'` matches the beginning of a string, and `'$'` matches the end of a string.",
        "source": "book"
    },
    {
        "name": "String substitution",
        "tags": [
            "regex substitution",
            "pattern groups",
            "optional characters"
        ],
        "summary": "Using regular expressions for advanced find-and-replace operations with pattern matching.",
        "content": "We can use the `sub` function in the `re` module, which does **string substitution**. The first argument is the pattern we want to find and replace, the second is what we want to replace it with, and the third is the string we want to search.\n\nRegular expressions support more advanced patterns. For example, parentheses enclose the part of the pattern the vertical bar applies to. The special character `'?'` means that the previous character is optional. This allows for flexible pattern matching that can handle variations in spelling or formatting.",
        "source": "book"
    },
    {
        "name": "Debugging",
        "tags": [
            "debugging",
            "shell commands",
            "file inspection"
        ],
        "summary": "Using shell commands and file inspection techniques for debugging file processing operations.",
        "content": "When you are reading and writing files, debugging can be tricky. If you are working in a Jupyter notebook, you can use **shell commands** to help. For example, to display the first few lines of a file, you can use the command `!head`, and to display the last few lines, you can use `!tail`.\n\nThe initial exclamation point, `!`, indicates that this is a shell command, which is not part of Python. When you are working with large files, debugging can be difficult because there might be too much output to check by hand. A good debugging strategy is to start with just part of the file, get the program working, and then run it with the whole file.",
        "source": "book"
    },
    {
        "name": "Lists Introduction",
        "tags": [
            "list",
            "sequence",
            "elements"
        ],
        "summary": "A list is a sequence of values that can be of any type, similar to strings but more flexible.",
        "content": "Like a string, a **list** is a sequence of values. In a string, the values are characters; in a list, they can be any type. The values in a list are called **elements**.\n\nThere are several ways to create a new list; the simplest is to enclose the elements in square brackets (`[` and `]`).\n\n```python\nnumbers = [42, 123]\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n```\n\nThe elements of a list don't have to be the same type. The following list contains a string, a float, an integer, and even another list.\n\n```python\nt = ['spam', 2.0, 5, [10, 20]]\n```\n\nA list within another list is **nested**. A list that contains no elements is called an empty list; you can create one with empty brackets, `[]`.\n\n```python\nempty = []\n```\n\nThe `len` function returns the length of a list.\n\n```python\nlen(cheeses)  # Returns 3\nlen(empty)   # Returns 0\n```",
        "source": "book"
    },
    {
        "name": "Lists Are Mutable",
        "tags": [
            "mutable",
            "indexing",
            "assignment"
        ],
        "summary": "Lists are mutable sequences that can be modified by assigning to elements using bracket notation.",
        "content": "To read an element of a list, we can use the bracket operator. The index of the first element is `0`.\n\n```python\ncheeses[0]  # Returns 'Cheddar'\n```\n\nUnlike strings, lists are mutable. When the bracket operator appears on the left side of an assignment, it identifies the element of the list that will be assigned.\n\n```python\nnumbers[1] = 17\nnumbers  # Returns [42, 17]\n```\n\nList indices work the same way as string indices:\n\n- Any integer expression can be used as an index.\n- If you try to read or write an element that does not exist, you get an `IndexError`.\n- If an index has a negative value, it counts backward from the end of the list.\n\nThe `in` operator works on lists -- it checks whether a given element appears anywhere in the list.\n\n```python\n'Edam' in cheeses        # Returns True\n'Wensleydale' in cheeses # Returns False\n```\n\nAlthough a list can contain another list, the nested list still counts as a single element.\n\n```python\nt = ['spam', 2.0, 5, [10, 20]]\nlen(t)  # Returns 4\n10 in t # Returns False\n```",
        "source": "book"
    },
    {
        "name": "List Slices",
        "tags": [
            "slicing",
            "copying",
            "subsets"
        ],
        "summary": "List slicing allows you to extract subsets of lists using the same syntax as string slicing.",
        "content": "The slice operator works on lists the same way it works on strings. The following example selects the second and third elements from a list of four letters.\n\n```python\nletters = ['a', 'b', 'c', 'd']\nletters[1:3]  # Returns ['b', 'c']\n```\n\nIf you omit the first index, the slice starts at the beginning.\n\n```python\nletters[:2]  # Returns ['a', 'b']\n```\n\nIf you omit the second, the slice goes to the end.\n\n```python\nletters[2:]  # Returns ['c', 'd']\n```\n\nSo if you omit both, the slice is a copy of the whole list.\n\n```python\nletters[:]  # Returns ['a', 'b', 'c', 'd']\n```\n\nAnother way to copy a list is to use the `list` function.\n\n```python\nlist(letters)  # Returns ['a', 'b', 'c', 'd']\n```\n\nBecause `list` is the name of a built-in function, you should avoid using it as a variable name.",
        "source": "book"
    },
    {
        "name": "List Operations",
        "tags": [
            "concatenation",
            "repetition",
            "mathematical operations"
        ],
        "summary": "Lists support concatenation with +, repetition with *, and mathematical operations with built-in functions.",
        "content": "The `+` operator concatenates lists.\n\n```python\nt1 = [1, 2]\nt2 = [3, 4]\nt1 + t2  # Returns [1, 2, 3, 4]\n```\n\nThe `*` operator repeats a list a given number of times.\n\n```python\n['spam'] * 4  # Returns ['spam', 'spam', 'spam', 'spam']\n```\n\nNo other mathematical operators work with lists, but the built-in function `sum` adds up the elements.\n\n```python\nsum(t1)  # Returns 3\n```\n\nAnd `min` and `max` find the smallest and largest elements.\n\n```python\nmin(t1)  # Returns 1\nmax(t2)  # Returns 4\n```",
        "source": "book"
    },
    {
        "name": "List Methods",
        "tags": [
            "methods",
            "modification",
            "removal"
        ],
        "summary": "Python provides methods to modify lists, including adding elements with append and extend, and removing elements with pop and remove.",
        "content": "Python provides methods that operate on lists. For example, `append` adds a new element to the end of a list:\n\n```python\nletters.append('e')\nletters  # Returns ['a', 'b', 'c', 'd', 'e']\n```\n\n`extend` takes a list as an argument and appends all of the elements:\n\n```python\nletters.extend(['f', 'g'])\nletters  # Returns ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n```\n\nThere are two methods that remove elements from a list. If you know the index of the element you want, you can use `pop`.\n\n```python\nt = ['a', 'b', 'c']\nt.pop(1)  # Returns 'b'\nt         # Returns ['a', 'c']\n```\n\nThe return value is the element that was removed.\n\nIf you know the element you want to remove (but not the index), you can use `remove`:\n\n```python\nt = ['a', 'b', 'c']\nt.remove('b')  # Returns None\nt              # Returns ['a', 'c']\n```\n\nThe return value from `remove` is `None`. If the element you ask for is not in the list, that's a ValueError.",
        "source": "book"
    },
    {
        "name": "Lists and Strings",
        "tags": [
            "conversion",
            "split",
            "join"
        ],
        "summary": "Strings can be converted to lists of characters or words, and lists of strings can be joined back into single strings.",
        "content": "A string is a sequence of characters and a list is a sequence of values, but a list of characters is not the same as a string. To convert from a string to a list of characters, you can use the `list` function.\n\n```python\ns = 'spam'\nt = list(s)\nt  # Returns ['s', 'p', 'a', 'm']\n```\n\nThe `list` function breaks a string into individual letters. If you want to break a string into words, you can use the `split` method:\n\n```python\ns = 'pining for the fjords'\nt = s.split()\nt  # Returns ['pining', 'for', 'the', 'fjords']\n```\n\nAn optional argument called a **delimiter** specifies which characters to use as word boundaries. The following example uses a hyphen as a delimiter.\n\n```python\ns = 'ex-parrot'\nt = s.split('-')\nt  # Returns ['ex', 'parrot']\n```\n\nIf you have a list of strings, you can concatenate them into a single string using `join`. `join` is a string method, so you have to invoke it on the delimiter and pass the list as an argument.\n\n```python\ndelimiter = ' '\nt = ['pining', 'for', 'the', 'fjords']\ns = delimiter.join(t)\ns  # Returns 'pining for the fjords'\n```\n\nIn this case the delimiter is a space character, so `join` puts a space between words. To join strings without spaces, you can use the empty string, `''`, as a delimiter.",
        "source": "book"
    },
    {
        "name": "Looping Through a List",
        "tags": [
            "iteration",
            "for loop",
            "empty lists"
        ],
        "summary": "For loops can iterate through list elements, and empty lists result in no iterations.",
        "content": "You can use a `for` statement to loop through the elements of a list.\n\n```python\nfor cheese in cheeses:\n    print(cheese)\n```\n\nFor example, after using `split` to make a list of words, we can use `for` to loop through them.\n\n```python\ns = 'pining for the fjords'\n\nfor word in s.split():\n    print(word)\n```\n\nA `for` loop over an empty list never runs the indented statements.\n\n```python\nfor x in []:\n    print('This never happens.')\n```",
        "source": "book"
    },
    {
        "name": "Sorting Lists",
        "tags": [
            "sorting",
            "sorted",
            "immutability"
        ],
        "summary": "The sorted function returns a new sorted list without modifying the original, and can be used with any sequence.",
        "content": "Python provides a built-in function called `sorted` that sorts the elements of a list.\n\n```python\nscramble = ['c', 'a', 'b']\nsorted(scramble)  # Returns ['a', 'b', 'c']\n```\n\nThe original list is unchanged.\n\n```python\nscramble  # Returns ['c', 'a', 'b']\n```\n\n`sorted` works with any kind of sequence, not just lists. So we can sort the letters in a string like this.\n\n```python\nsorted('letters')  # Returns ['e', 'e', 'l', 'r', 's', 't', 't']\n```\n\nThe result is a list. To convert the list to a string, we can use `join`.\n\n```python\n''.join(sorted('letters'))  # Returns 'eelrstt'\n```\n\nWith an empty string as the delimiter, the elements of the list are joined with nothing between them.",
        "source": "book"
    },
    {
        "name": "Objects and Values",
        "tags": [
            "identity",
            "equivalence",
            "references"
        ],
        "summary": "Variables can refer to the same object (identical) or different objects with the same value (equivalent).",
        "content": "If we run these assignment statements:\n\n```python\na = 'banana'\nb = 'banana'\n```\n\nWe know that `a` and `b` both refer to a string, but we don't know whether they refer to the *same* string. To check whether two variables refer to the same object, you can use the `is` operator.\n\n```python\na = 'banana'\nb = 'banana'\na is b  # Returns True\n```\n\nIn this example, Python only created one string object, and both `a` and `b` refer to it. But when you create two lists, you get two objects.\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\na is b  # Returns False\n```\n\nIn this case we would say that the two lists are **equivalent**, because they have the same elements, but not **identical**, because they are not the same object. If two objects are identical, they are also equivalent, but if they are equivalent, they are not necessarily identical.",
        "source": "book"
    },
    {
        "name": "Aliasing",
        "tags": [
            "aliasing",
            "references",
            "mutation"
        ],
        "summary": "When multiple variables refer to the same mutable object, changes through one variable affect all references.",
        "content": "If `a` refers to an object and you assign `b = a`, then both variables refer to the same object.\n\n```python\na = [1, 2, 3]\nb = a\nb is a  # Returns True\n```\n\nThe association of a variable with an object is called a **reference**. In this example, there are two references to the same object.\n\nAn object with more than one reference has more than one name, so we say the object is **aliased**. If the aliased object is mutable, changes made with one name affect the other. In this example, if we change the object `b` refers to, we are also changing the object `a` refers to.\n\n```python\nb[0] = 5\na  # Returns [5, 2, 3]\n```\n\nSo we would say that `a` \"sees\" this change. Although this behavior can be useful, it is error-prone. In general, it is safer to avoid aliasing when you are working with mutable objects.\n\nFor immutable objects like strings, aliasing is not as much of a problem.\n\n```python\na = 'banana'\nb = 'banana'\n```\n\nIt almost never makes a difference whether `a` and `b` refer to the same string or not.",
        "source": "book"
    },
    {
        "name": "List Arguments",
        "tags": [
            "functions",
            "parameters",
            "modification"
        ],
        "summary": "When lists are passed to functions, the function receives a reference to the original list, allowing modification of the caller's data.",
        "content": "When you pass a list to a function, the function gets a reference to the list. If the function modifies the list, the caller sees the change. For example, `pop_first` uses the list method `pop` to remove the first element from a list.\n\n```python\ndef pop_first(lst):\n    return lst.pop(0)\n```\n\nWe can use it like this.\n\n```python\nletters = ['a', 'b', 'c']\npop_first(letters)  # Returns 'a'\nletters             # Returns ['b', 'c']\n```\n\nThe return value is the first element, which has been removed from the list.\n\nIn this example, the parameter `lst` and the variable `letters` are aliases for the same object.\n\nPassing a reference to an object as an argument to a function creates a form of aliasing. If the function modifies the object, those changes persist after the function is done.",
        "source": "book"
    },
    {
        "name": "Making a Word List",
        "tags": [
            "file processing",
            "efficiency",
            "word lists"
        ],
        "summary": "Reading words from a file into a list allows efficient searching and processing without repeated file access.",
        "content": "In the previous chapter, we read the file `words.txt` and searched for words with certain properties, like using the letter `e`. But we read the entire file many times, which is not efficient. It is better to read the file once and put the words in a list. The following loop shows how.\n\n```python\nword_list = []\n\nfor line in open('words.txt'):\n    word = line.strip()\n    word_list.append(word)\n\nlen(word_list)  # Returns more than 113,000\n```\n\nBefore the loop, `word_list` is initialized with an empty list. Each time through the loop, the `append` method adds a word to the end. When the loop is done, there are more than 113,000 words in the list.\n\nAnother way to do the same thing is to use `read` to read the entire file into a string.\n\n```python\nstring = open('words.txt').read()\nlen(string)  # Returns more than a million characters\n```\n\nThe result is a single string with more than a million characters. We can use the `split` method to split it into a list of words.\n\n```python\nword_list = string.split()\nlen(word_list)  # Returns more than 113,000\n```\n\nNow, to check whether a string appears in the list, we can use the `in` operator. For example, `'demotic'` is in the list.\n\n```python\n'demotic' in word_list  # Returns True\n```\n\nBut `'contrafibularities'` is not.\n\n```python\n'contrafibularities' in word_list  # Returns False\n```",
        "source": "book"
    },
    {
        "name": "Debugging Lists",
        "tags": [
            "debugging",
            "methods",
            "common errors"
        ],
        "summary": "List methods modify the list in place and return None, unlike string methods that return new strings.",
        "content": "Note that most list methods modify the argument and return `None`. This is the opposite of the string methods, which return a new string and leave the original alone.\n\nIf you are used to writing string code like this:\n\n```python\nword = 'plumage!'\nword = word.strip('!')\nword  # Returns 'plumage'\n```\n\nIt is tempting to write list code like this:\n\n```python\nt = [1, 2, 3]\nt = t.remove(3)  # WRONG!\n```\n\n`remove` modifies the list and returns `None`, so next operation you perform with `t` is likely to fail.\n\n```python\nt.remove(2)  # AttributeError: 'NoneType' object has no attribute 'remove'\n```\n\nThis error message takes some explaining. An **attribute** of an object is a variable or method associated with it. In this case, the value of `t` is `None`, which is a `NoneType` object, which does not have a attribute named `remove`, so the result is an `AttributeError`.\n\nIf you see an error message like this, you should look backward through the program and see if you might have called a list method incorrectly.",
        "source": "book"
    },
    {
        "name": "Dictionaries Introduction",
        "tags": [
            "dictionary",
            "mapping",
            "key-value pairs"
        ],
        "summary": "A dictionary is a mapping from keys to values, more general than lists as keys can be almost any type.",
        "content": "A **dictionary** is like a list, but more general. In a list, the indices have to be integers; in a dictionary they can be (almost) any type.\n\nWe create an empty dictionary using curly braces `{}`:\n\n```python\nnumbers = {}\n```\n\nTo add items to the dictionary, we use square brackets:\n\n```python\nnumbers['zero'] = 0\n```\n\nThis assignment adds to the dictionary an **item**, which represents the association of a **key** and a **value**. In this example, the key is the string `'zero'` and the value is the integer `0`.\n\nWe can add more items and display the dictionary:\n\n```python\nnumbers['one'] = 1\nnumbers['two'] = 2\nnumbers  # Returns {'zero': 0, 'one': 1, 'two': 2}\n```\n\nTo look up a key and get the corresponding value, we use the bracket operator:\n\n```python\nnumbers['two']  # Returns 2\n```\n\nIf the key isn't in the dictionary, we get a `KeyError`.\n\nThe `len` function works on dictionaries; it returns the number of items.\n\nIn mathematical language, a dictionary represents a **mapping** from keys to values, so you can also say that each key \"maps to\" a value.",
        "source": "book"
    },
    {
        "name": "Creating Dictionaries",
        "tags": [
            "dictionary creation",
            "dict function",
            "copying"
        ],
        "summary": "Dictionaries can be created using curly braces with key-value pairs or using the dict function.",
        "content": "Instead of creating an empty dictionary and adding items one at a time, we can create the dictionary all at once:\n\n```python\nnumbers = {'zero': 0, 'one': 1, 'two': 2}\n```\n\nEach item consists of a key and a value separated by a colon. The items are separated by commas and enclosed in curly braces.\n\nAnother way to create a dictionary is to use the `dict` function. We can make an empty dictionary like this:\n\n```python\nempty = dict()\nempty  # Returns {}\n```\n\nAnd we can make a copy of a dictionary like this:\n\n```python\nnumbers_copy = dict(numbers)\nnumbers_copy  # Returns {'zero': 0, 'one': 1, 'two': 2}\n```\n\nIt is often useful to make a copy before performing operations that modify dictionaries.",
        "source": "book"
    },
    {
        "name": "The in Operator with Dictionaries",
        "tags": [
            "membership testing",
            "keys",
            "values"
        ],
        "summary": "The in operator checks for key existence in dictionaries, and hash tables enable efficient lookups regardless of dictionary size.",
        "content": "The `in` operator works on dictionaries; it tells you whether something appears as a *key* in the dictionary.\n\n```python\n'one' in numbers  # Returns True\n```\n\nThe `in` operator does *not* check whether something appears as a value:\n\n```python\n1 in numbers  # Returns False\n```\n\nTo see whether something appears as a value in a dictionary, you can use the method `values`, which returns a sequence of values, and then use the `in` operator:\n\n```python\n1 in numbers.values()  # Returns True\n```\n\nThe items in a Python dictionary are stored in a **hash table**, which is a way of organizing data that has a remarkable property: the `in` operator takes about the same amount of time no matter how many items are in the dictionary. That makes it possible to write some remarkably efficient algorithms.\n\nIn general, the time it takes to find an element in a list is proportional to the length of the list. The time it takes to find a key in a dictionary is almost constant -- regardless of the number of items.",
        "source": "book"
    },
    {
        "name": "A Collection of Counters",
        "tags": [
            "counting",
            "frequency analysis",
            "value tracking"
        ],
        "summary": "Dictionaries can be used to count the frequency of elements by using keys to track elements and values to store counts.",
        "content": "Suppose you are given a string and you want to count how many times each letter appears. A dictionary is a good tool for this job. We'll start with an empty dictionary:\n\n```python\ncounter = {}\n```\n\nAs we loop through the letters in the string, we can add letters to the dictionary and increment their counts:\n\n```python\ncounter['a'] = 1  # First occurrence\ncounter['a'] += 1 # Increment count\ncounter  # Returns {'a': 2}\n```\n\nThe following function uses these features to count the number of times each letter appears in a string:\n\n```python\ndef value_counts(string):\n    counter = {}\n    for letter in string:\n        if letter not in counter:\n            counter[letter] = 1\n        else:\n            counter[letter] += 1\n    return counter\n```\n\nEach time through the loop, if `letter` is not in the dictionary, we create a new item with key `letter` and value `1`. If `letter` is already in the dictionary we increment the value associated with `letter`.\n\nExample usage:\n\n```python\ncounter = value_counts('brontosaurus')\ncounter  # Returns {'b': 1, 'r': 2, 'o': 2, 'n': 1, 't': 1, 's': 2, 'a': 1, 'u': 2}\n```",
        "source": "book"
    },
    {
        "name": "Looping and Dictionaries",
        "tags": [
            "iteration",
            "keys",
            "values",
            "items"
        ],
        "summary": "For loops can iterate through dictionary keys, and methods are available to access values and key-value pairs.",
        "content": "If you use a dictionary in a `for` statement, it traverses the keys of the dictionary. To demonstrate, let's make a dictionary that counts the letters in `'banana'`:\n\n```python\ncounter = value_counts('banana')\ncounter  # Returns {'b': 1, 'a': 3, 'n': 2}\n```\n\nThe following loop prints the keys, which are the letters:\n\n```python\nfor key in counter:\n    print(key)\n```\n\nTo print the values, we can use the `values` method:\n\n```python\nfor value in counter.values():\n    print(value)\n```\n\nTo print the keys and values, we can loop through the keys and look up the corresponding values:\n\n```python\nfor key in counter:\n    value = counter[key]\n    print(key, value)\n```",
        "source": "book"
    },
    {
        "name": "Lists and Dictionaries",
        "tags": [
            "nested data",
            "hashable",
            "immutable keys"
        ],
        "summary": "Lists can be values in dictionaries but not keys, as dictionary keys must be hashable and immutable.",
        "content": "You can put a list in a dictionary as a value. For example, here's a dictionary that maps from the number `4` to a list of four letters:\n\n```python\nd = {4: ['r', 'o', 'u', 's']}\nd  # Returns {4: ['r', 'o', 'u', 's']}\n```\n\nBut you can't put a list in a dictionary as a key. Dictionaries use hash tables, which means that the keys have to be **hashable**.\n\nA **hash** is a function that takes a value (of any kind) and returns an integer. Dictionaries use these integers, called hash values, to store and look up keys.\n\nThis system only works if a key is immutable, so its hash value is always the same. But if a key is mutable, its hash value could change, and the dictionary would not work. That's why keys have to be hashable, and why mutable types like lists aren't.\n\nSince dictionaries are mutable, they can't be used as keys, either. But they *can* be used as values.",
        "source": "book"
    },
    {
        "name": "Accumulating a List",
        "tags": [
            "accumulator",
            "filtering",
            "list building"
        ],
        "summary": "Lists can be built by accumulating elements that meet certain criteria during iteration.",
        "content": "For many programming tasks, it is useful to loop through one list or dictionary while building another. As an example, we can loop through words and make a list of palindromes:\n\n```python\ndef is_palindrome(word):\n    \"\"\"Check if a word is a palindrome.\"\"\"\n    return reverse_word(word) == word\n\npalindromes = []\n\nfor word in word_dict:\n    if is_palindrome(word):\n        palindromes.append(word)\n\npalindromes[:10]  # Returns first 10 palindromes\n```\n\nHere's how it works:\n\n* Before the loop, `palindromes` is initialized with an empty list.\n* Inside the loop, if `word` is a palindrome, we append it to the end of `palindromes`.\n* When the loop ends, `palindromes` is a list of palindromes.\n\nIn this loop, `palindromes` is used as an **accumulator**, which is a variable that collects or accumulates data during a computation.\n\nNow suppose we want to select only palindromes with seven or more letters. We can loop through `palindromes` and make a new list that contains only long palindromes:\n\n```python\nlong_palindromes = []\n\nfor word in palindromes:\n    if len(word) >= 7:\n        long_palindromes.append(word)\n\nlong_palindromes  # Returns list of long palindromes\n```\n\nLooping through a list like this, selecting some elements and omitting others, is called **filtering**.",
        "source": "book"
    },
    {
        "name": "Memos",
        "tags": [
            "memoization",
            "optimization",
            "recursion"
        ],
        "summary": "Memoization stores previously computed values to avoid redundant calculations in recursive functions.",
        "content": "If you ran the `fibonacci` function, you might notice that the bigger the argument, the longer the function takes to run. Furthermore, the run time increases quickly.\n\nOne solution is to keep track of values that have already been computed by storing them in a dictionary. A previously computed value that is stored for later use is called a **memo**. Here is a \"memoized\" version of `fibonacci`:\n\n```python\nknown = {0:0, 1:1}\n\ndef fibonacci_memo(n):\n    if n in known:\n        return known[n]\n\n    res = fibonacci_memo(n-1) + fibonacci_memo(n-2)\n    known[n] = res\n    return res\n```\n\n`known` is a dictionary that keeps track of the Fibonacci numbers we already know. It starts with two items: `0` maps to `0` and `1` maps to `1`.\n\nWhenever `fibonacci_memo` is called, it checks `known`. If the result is already there, it can return immediately. Otherwise it has to compute the new value, add it to the dictionary, and return it.\n\nComparing the two functions, `fibonacci(40)` takes about 30 seconds to run. `fibonacci_memo(40)` takes about 30 microseconds, so it's a million times faster.",
        "source": "book"
    },
    {
        "name": "Debugging with Large Datasets",
        "tags": [
            "debugging",
            "scaling",
            "validation"
        ],
        "summary": "Strategies for debugging large datasets include scaling down input, checking summaries, writing self-checks, and formatting output.",
        "content": "As you work with bigger datasets it can become unwieldy to debug by printing and checking the output by hand. Here are some suggestions for debugging large datasets:\n\n1. **Scale down the input**: If possible, reduce the size of the dataset. For example if the program reads a text file, start with just the first 10 lines, or with the smallest example you can find. You can either edit the files themselves, or (better) modify the program so it reads only the first `n` lines.\n\n2. **Check summaries and types**: Instead of printing and checking the entire dataset, consider printing summaries of the data -- for example, the number of items in a dictionary or the total of a list of numbers. A common cause of runtime errors is a value that is not the right type. For debugging this kind of error, it is often enough to print the type of a value.\n\n3. **Write self-checks**: Sometimes you can write code to check for errors automatically. For example, if you are computing the average of a list of numbers, you could check that the result is not greater than the largest element in the list or less than the smallest. This is called a \"sanity check\" because it detects results that are \"insane\". Another kind of check compares the results of two different computations to see if they are consistent. This is called a \"consistency check\".\n\n4. **Format the output**: Formatting debugging output can make it easier to spot an error. Another tool you might find useful is the `pprint` module, which provides a `pprint` function that displays built-in types in a more human-readable format (`pprint` stands for \"pretty print\").",
        "source": "book"
    },
    {
        "name": "Tuples Introduction",
        "tags": [
            "tuple",
            "immutable",
            "sequence"
        ],
        "summary": "Tuples are immutable sequences similar to lists, introduced for working with multiple data types together and supporting tuple assignment and variable-length arguments.",
        "content": "This chapter introduces one more built-in type, the tuple, and then shows how lists, dictionaries, and tuples work together. It also presents tuple assignment and a useful feature for functions with variable-length argument lists: the packing and unpacking operators.\n\nOne note: There are two ways to pronounce \"tuple\". Some people say \"tuh-ple\", which rhymes with \"supple\". But in the context of programming, most people say \"too-ple\", which rhymes with \"quadruple\".",
        "source": "book"
    },
    {
        "name": "Tuple Creation",
        "tags": [
            "tuple",
            "creation",
            "syntax"
        ],
        "summary": "Tuples can be created using comma-separated values, with or without parentheses, and using the tuple() constructor function.",
        "content": "A tuple is a sequence of values. The values can be any type, and they are indexed by integers, so tuples are a lot like lists. The important difference is that tuples are immutable.\n\nTo create a tuple, you can write a comma-separated list of values:\n```python\nt = 'l', 'u', 'p', 'i', 'n'\n```\n\nAlthough it is not necessary, it is common to enclose tuples in parentheses:\n```python\nt = ('l', 'u', 'p', 'i', 'n')\n```\n\nTo create a tuple with a single element, you have to include a final comma:\n```python\nt1 = 'p',\n```\n\nA single value in parentheses is not a tuple:\n```python\nt2 = ('p')  # This is a string, not a tuple\n```\n\nAnother way to create a tuple is the built-in function `tuple`. With no argument, it creates an empty tuple:\n```python\nt = tuple()\n```\n\nIf the argument is a sequence (string, list or tuple), the result is a tuple with the elements of the sequence:\n```python\nt = tuple('lupin')\n```",
        "source": "book"
    },
    {
        "name": "Tuple Operations",
        "tags": [
            "tuple",
            "operations",
            "indexing",
            "slicing"
        ],
        "summary": "Tuples support most list operations including indexing, slicing, concatenation, and repetition, but are immutable.",
        "content": "Most list operators also work with tuples. For example, the bracket operator indexes an element:\n```python\nt[0]  # 'l'\n```\n\nAnd the slice operator selects a range of elements:\n```python\nt[1:3]  # ('u', 'p')\n```\n\nThe `+` operator concatenates tuples:\n```python\ntuple('lup') + ('i', 'n')  # ('l', 'u', 'p', 'i', 'n')\n```\n\nAnd the `*` operator duplicates a tuple a given number of times:\n```python\ntuple('spam') * 2  # ('s', 'p', 'a', 'm', 's', 'p', 'a', 'm')\n```\n\nThe `sorted` function works with tuples -- but the result is a list, not a tuple:\n```python\nsorted(t)  # ['i', 'l', 'n', 'p', 'u']\n```\n\nThe `reversed` function also works with tuples:\n```python\nreversed(t)  # returns a reversed object\n```\n\nWe can convert the reversed object to a tuple:\n```python\ntuple(reversed(t))  # ('n', 'i', 'p', 'u', 'l')\n```",
        "source": "book"
    },
    {
        "name": "Tuple Immutability",
        "tags": [
            "tuple",
            "immutable",
            "hashable"
        ],
        "summary": "Tuples are immutable and cannot be modified after creation, making them hashable and suitable for use as dictionary keys.",
        "content": "If you try to modify a tuple with the bracket operator, you get a `TypeError`:\n```python\n%%expect TypeError\nt[0] = 'L'\n```\n\nAnd tuples don't have any of the methods that modify lists, like `append` and `remove`:\n```python\n%%expect AttributeError\nt.remove('l')\n```\n\nBecause tuples are immutable, they are hashable, which means they can be used as keys in a dictionary:\n```python\nd = {}\nd[1, 2] = 3\nd[3, 4] = 7\n```\n\nWe can look up a tuple in a dictionary like this:\n```python\nd[1, 2]  # 3\n```\n\nOr if we have a variable that refers to a tuple, we can use it as a key:\n```python\nt = (3, 4)\nd[t]  # 7\n```\n\nTuples can also appear as values in a dictionary:\n```python\nt = tuple('abc')\nd = {'key': t}\n```",
        "source": "book"
    },
    {
        "name": "Tuple Assignment",
        "tags": [
            "tuple",
            "assignment",
            "unpacking"
        ],
        "summary": "Tuple assignment allows multiple variables to be assigned values from a tuple in a single statement, useful for swapping values and iterating through dictionary items.",
        "content": "You can put a tuple of variables on the left side of an assignment, and a tuple of values on the right:\n```python\na, b = 1, 2\n```\n\nThe values are assigned to the variables from left to right -- in this example, `a` gets the value `1` and `b` gets the value `2`.\n\nMore generally, if the left side of an assignment is a tuple, the right side can be any kind of sequence -- string, list or tuple. For example, to split an email address into a user name and a domain:\n```python\nemail = 'monty@python.org'\nusername, domain = email.split('@')\n```\n\nThe number of variables on the left and the number of values on the right have to be the same -- otherwise you get a `ValueError`.\n\nTuple assignment is useful if you want to swap the values of two variables:\n```python\na, b = b, a\n```\n\nThis works because all of the expressions on the right side are evaluated before any of the assignments.\n\nWe can also use tuple assignment in a `for` statement. For example, to loop through the items in a dictionary:\n```python\nd = {'one': 1, 'two': 2}\n\nfor item in d.items():\n    key, value = item\n    print(key, '->', value)\n```\n\nWe can write this loop more concisely:\n```python\nfor key, value in d.items():\n    print(key, '->', value)\n```",
        "source": "book"
    },
    {
        "name": "Tuples as Return Values",
        "tags": [
            "tuple",
            "return",
            "multiple values"
        ],
        "summary": "Functions can return tuples to effectively return multiple values, which can then be unpacked using tuple assignment.",
        "content": "Strictly speaking, a function can only return one value, but if the value is a tuple, the effect is the same as returning multiple values. For example, the built-in function `divmod` takes two arguments and returns a tuple of two values, the quotient and remainder:\n```python\ndivmod(7, 3)  # (2, 1)\n```\n\nWe can use tuple assignment to store the elements of the tuple in two variables:\n```python\nquotient, remainder = divmod(7, 3)\n```\n\nHere is an example of a function that returns a tuple:\n```python\ndef min_max(t):\n    return min(t), max(t)\n```\n\n`max` and `min` are built-in functions that find the largest and smallest elements of a sequence. `min_max` computes both and returns a tuple of two values:\n```python\nmin_max([2, 4, 1, 3])  # (1, 4)\n```\n\nWe can assign the results to variables like this:\n```python\nlow, high = min_max([2, 4, 1, 3])\n```",
        "source": "book"
    },
    {
        "name": "Argument Packing and Unpacking",
        "tags": [
            "tuple",
            "packing",
            "unpacking",
            "variable arguments"
        ],
        "summary": "The * operator can pack multiple arguments into a tuple or unpack a tuple into multiple function arguments.",
        "content": "Functions can take a variable number of arguments. A parameter name that begins with the `*` operator **packs** arguments into a tuple:\n```python\ndef mean(*args):\n    return sum(args) / len(args)\n```\n\nThe parameter can have any name you like, but `args` is conventional.\n\nIf you have a sequence of values and you want to pass them to a function as multiple arguments, you can use the `*` operator to **unpack** the tuple:\n```python\nt = (7, 3)\ndivmod(*t)  # equivalent to divmod(7, 3)\n```\n\nPacking and unpacking can be useful if you want to adapt the behavior of an existing function. For example, this function takes any number of arguments, removes the lowest and highest, and computes the mean of the rest:\n```python\ndef trimmed_mean(*args):\n    low, high = min_max(args)\n    trimmed = list(args)\n    trimmed.remove(low)\n    trimmed.remove(high)\n    return mean(*trimmed)\n```",
        "source": "book"
    },
    {
        "name": "Zip Function",
        "tags": [
            "tuple",
            "zip",
            "iteration",
            "pairing"
        ],
        "summary": "The zip function pairs elements from multiple sequences into tuples, useful for iterating through corresponding elements.",
        "content": "Tuples are useful for looping through the elements of two sequences and performing operations on corresponding elements. We can use `zip`, which is a built-in function that takes two or more sequences and returns a **zip object**, so-called because it pairs up the elements of the sequences like the teeth of a zipper.\n\nWe can use the zip object to loop through the values in the sequences pairwise:\n```python\nscores1 = [1, 2, 4, 5, 1, 5, 2]\nscores2 = [5, 5, 2, 2, 5, 2, 3]\n\nfor pair in zip(scores1, scores2):\n    print(pair)\n```\n\nEach time through the loop, `pair` gets assigned a tuple of scores. So we can assign the scores to variables:\n```python\nwins = 0\nfor team1, team2 in zip(scores1, scores2):\n    if team1 > team2:\n        wins += 1\n```\n\nIf you have two lists and you want a list of pairs, you can use `zip` and `list`:\n```python\nt = list(zip(scores1, scores2))\n```\n\nIf you have a list of keys and a list of values, you can use `zip` and `dict` to make a dictionary:\n```python\nletters = 'abcdefghijklmnopqrstuvwxyz'\nnumbers = range(len(letters))\nletter_map = dict(zip(letters, numbers))\n```",
        "source": "book"
    },
    {
        "name": "Enumerate Function",
        "tags": [
            "tuple",
            "enumerate",
            "iteration",
            "index"
        ],
        "summary": "The enumerate function returns tuples containing indices and elements from a sequence, useful for looping with indices.",
        "content": "If you need to loop through the elements of a sequence and their indices, you can use the built-in function `enumerate`:\n```python\nenumerate('abc')\n```\n\nThe result is an **enumerate object** that loops through a sequence of pairs, where each pair contains an index (starting from 0) and an element from the given sequence:\n```python\nfor index, element in enumerate('abc'):\n    print(index, element)\n```\n\nThis would output:\n```\n0 a\n1 b\n2 c\n```",
        "source": "book"
    },
    {
        "name": "Tuple Comparison and Sorting",
        "tags": [
            "tuple",
            "comparison",
            "sorting",
            "key"
        ],
        "summary": "Tuples can be compared lexicographically and sorted using custom key functions to determine sort order.",
        "content": "The relational operators work with tuples and other sequences. For example, if you use the `<` operator with tuples, it starts by comparing the first element from each sequence. If they are equal, it goes on to the next pair of elements, and so on, until it finds a pair that differ:\n```python\n(0, 1, 2) < (0, 3, 4)  # True\n```\n\nSubsequent elements are not considered -- even if they are really big:\n```python\n(0, 1, 2000000) < (0, 3, 4)  # True\n```\n\nThis way of comparing tuples is useful for sorting a list of tuples, or finding the minimum or maximum. To sort by a specific element, we can use a key function:\n```python\ndef second_element(t):\n    return t[1]\n\nsorted_items = sorted(items, key=second_element)\n```\n\nThe sort key determines the order of the items in the list. We can also use `max` with a key function:\n```python\nmax(items, key=second_element)\n```",
        "source": "book"
    },
    {
        "name": "Inverting Dictionaries with Tuples",
        "tags": [
            "tuple",
            "dictionary",
            "inversion",
            "data structure"
        ],
        "summary": "Dictionaries can be inverted using tuples and lists to handle non-unique values, creating mappings from values to lists of keys.",
        "content": "Suppose you want to invert a dictionary so you can look up a value and get the corresponding key. But there's a problem -- the keys in a dictionary have to be unique, but the values don't. So one way to invert a dictionary is to create a new dictionary where the values are lists of keys from the original.\n\nThe following function takes a dictionary and returns its inverse as a new dictionary:\n```python\ndef invert_dict(d):\n    new = {}\n    for key, value in d.items():\n        if value not in new:\n            new[value] = [key]\n        else:\n            new[value].append(key)\n    return new\n```\n\nThe `for` statement loops through the keys and values in `d`. If the value is not already in the new dictionary, it is added and associated with a list that contains a single element. Otherwise it is appended to the existing list.\n\nThis is the first example we've seen where the values in the dictionary are lists.",
        "source": "book"
    },
    {
        "name": "Data Structure Debugging",
        "tags": [
            "tuple",
            "data structure",
            "debugging",
            "structshape"
        ],
        "summary": "The structshape module helps debug complex data structures by summarizing their structure in a readable format.",
        "content": "Lists, dictionaries and tuples are **data structures**. In this chapter we are starting to see compound data structures, like lists of tuples, or dictionaries that contain tuples as keys and lists as values. Compound data structures are useful, but they are prone to errors caused when a data structure has the wrong type, size, or structure.\n\nTo help debug these kinds of errors, I wrote a module called `structshape` that provides a function, also called `structshape`, that takes any kind of data structure as an argument and returns a string that summarizes its structure.\n\nExamples:\n```python\nfrom structshape import structshape\n\nt = [1, 2, 3]\nstructshape(t)  # 'list of 3 int'\n\nt2 = [[1,2], [3,4], [5,6]]\nstructshape(t2)  # 'list of 3 list of 2 int'\n\nt3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]\nstructshape(t3)  # 'list of (3 int, float, 2 str, 2 list of int, int)'\n```\n\nIf you are having trouble keeping track of your data structures, `structshape` can help.",
        "source": "book"
    },
    {
        "name": "Tuple Glossary",
        "tags": [
            "tuple",
            "glossary",
            "definitions"
        ],
        "summary": "Key terms related to tuples including packing, unpacking, zip objects, enumerate objects, sort keys, and data structures.",
        "content": "**pack:** Collect multiple arguments into a tuple.\n\n**unpack:** Treat a tuple (or other sequence) as multiple arguments.\n\n**zip object:** The result of calling the built-in function `zip`, can be used to loop through a sequence of tuples.\n\n**enumerate object:** The result of calling the built-in function `enumerate`, can be used to loop through a sequence of tuples.\n\n**sort key:** A value, or function that computes a value, used to sort the elements of a collection.\n\n**data structure:** A collection of values, organized to perform certain operations efficiently.",
        "source": "book"
    },
    {
        "name": "Text Analysis and Generation Introduction",
        "tags": [
            "text analysis",
            "markov generation",
            "LLM"
        ],
        "summary": "Introduction to text analysis and Markov generation techniques for exploring statistical relationships between words and generating new text similar to the original.",
        "content": "At this point we have covered Python's core data structures -- lists, dictionaries, and tuples -- and some algorithms that use them. In this chapter, we'll use them to explore text analysis and Markov generation:\n\n* Text analysis is a way to describe the statistical relationships between the words in a document, like the probability that one word is followed by another, and\n\n* Markov generation is a way to generate new text with words and phrases similar to the original text.\n\nThese algorithms are similar to parts of a Large Language Model (LLM), which is the key component of a chatbot.",
        "source": "book"
    },
    {
        "name": "Unique Words Analysis",
        "tags": [
            "text processing",
            "unique words",
            "dictionary"
        ],
        "summary": "Analyzing unique words in text by reading files, splitting lines into words, and storing them as dictionary keys to count distinct vocabulary.",
        "content": "As a first step toward text analysis, let's read a book and count the number of unique words. We'll use a `for` loop to read lines from the file and `split` to divide the lines into words. Then, to keep track of unique words, we'll store each word as a key in a dictionary:\n\n```python\nunique_words = {}\nfor line in open(filename):\n    seq = line.split()\n    for word in seq:\n        unique_words[word] = 1\n\nlen(unique_words)\n```\n\nThe length of the dictionary is the number of unique words. We can inspect the longest words using `sorted` with the `len` function as a keyword argument:\n\n```python\nsorted(unique_words, key=len)[-5:]\n```",
        "source": "book"
    },
    {
        "name": "Text Cleaning and Punctuation Handling",
        "tags": [
            "text cleaning",
            "punctuation",
            "unicode"
        ],
        "summary": "Techniques for cleaning text by handling dashes, removing punctuation using Unicode categories, and normalizing words to lowercase.",
        "content": "To identify the words in the text, we need to deal with two issues:\n\n* When a dash appears in a line, we should replace it with a space -- then when we use `split`, the words will be separated.\n\n* After splitting the words, we can use `strip` to remove punctuation.\n\nTo handle the first issue, we can use the following function:\n```python\ndef split_line(line):\n    return line.replace('—', ' ').split()\n```\n\nTo remove punctuation, we can use the `unicodedata` module to identify punctuation characters:\n```python\nimport unicodedata\n\npunc_marks = {}\nfor line in open(filename):\n    for char in line:\n        category = unicodedata.category(char)\n        if category.startswith('P'):\n            punc_marks[char] = 1\n\npunctuation = ''.join(punc_marks)\n```\n\nNow we can write a function that cleans words:\n```python\ndef clean_word(word):\n    return word.strip(punctuation).lower()\n```\n\nThis approach leaves hyphenated words alone while removing punctuation from the beginning and end.",
        "source": "book"
    },
    {
        "name": "Word Frequency Counting",
        "tags": [
            "frequency counting",
            "dictionary",
            "sorting"
        ],
        "summary": "Counting word frequencies using dictionaries and sorting results to find the most common words in a text.",
        "content": "The following loop computes the frequency of each unique word:\n```python\nword_counter = {}\nfor line in open(filename):\n    for word in split_line(line):\n        word = clean_word(word)\n        if word not in word_counter:\n            word_counter[word] = 1\n        else:\n            word_counter[word] += 1\n```\n\nThe first time we see a word, we initialize its frequency to `1`. If we see the same word again later, we increment its frequency.\n\nTo see which words appear most often, we can use `items` to get the key-value pairs from `word_counter`, and sort them by frequency:\n```python\ndef second_element(t):\n    return t[1]\n\nitems = sorted(word_counter.items(), key=second_element, reverse=True)\n```\n\nWe can then display the most frequent words.",
        "source": "book"
    },
    {
        "name": "Optional Parameters",
        "tags": [
            "functions",
            "parameters",
            "default values"
        ],
        "summary": "Using optional parameters with default values to create flexible functions that can be called with different numbers of arguments.",
        "content": "We can write functions with optional parameters. For example, the following function takes two parameters, `word_counter` and `num`:\n```python\ndef print_most_common(word_counter, num=5):\n    items = sorted(word_counter.items(), key=second_element, reverse=True)\n\n    for word, freq in items[:num]:\n        print(freq, word, sep='\\t')\n```\n\nThe second parameter looks like an assignment statement, but it's not -- it's an optional parameter.\n\nIf you call this function with one argument, `num` gets the **default value**, which is `5`:\n```python\nprint_most_common(word_counter)\n```\n\nIf you call this function with two arguments, the second argument gets assigned to `num` instead of the default value:\n```python\nprint_most_common(word_counter, 3)\n```\n\nIn that case, we would say the optional argument **overrides** the default value.\n\nIf a function has both required and optional parameters, all of the required parameters have to come first, followed by the optional ones.",
        "source": "book"
    },
    {
        "name": "Dictionary Subtraction",
        "tags": [
            "dictionary",
            "set operations",
            "spell checking"
        ],
        "summary": "Using dictionary operations to find differences between sets of words, useful for spell checking and vocabulary analysis.",
        "content": "Suppose we want to spell-check a book -- that is, find a list of words that might be misspelled. One way to do that is to find words in the book that don't appear in a list of valid words.\n\nWe can think of this problem as set subtraction -- that is, we want to find all the words from one set (the words in the book) that are not in the other (the words in the list).\n\nThe following function takes two dictionaries as parameters and returns a new dictionary that contains all the keys from one that are not in the other:\n```python\ndef subtract(d1, d2):\n    res = {}\n    for key in d1:\n        if key not in d2:\n            res[key] = d1[key]\n    return res\n```\n\nHere's how we use it:\n```python\ndiff = subtract(word_counter, valid_words)\n```\n\nWe can then analyze the words that appear in the book but not in the valid word list to identify potential misspellings.",
        "source": "book"
    },
    {
        "name": "Random Number Generation",
        "tags": [
            "random",
            "probability",
            "weighted selection"
        ],
        "summary": "Using Python's random module for pseudorandom number generation and weighted selection of elements based on frequency.",
        "content": "Given the same inputs, most computer programs are **deterministic**, which means they generate the same outputs every time. For some applications, though, we want the computer to be unpredictable.\n\nMaking a program truly nondeterministic turns out to be difficult, but there are ways to fake it. One is to use algorithms that generate **pseudorandom** numbers. Pseudorandom numbers are not truly random because they are generated by a deterministic computation, but just by looking at the numbers it is all but impossible to distinguish them from random.\n\nThe `random` module provides functions that generate pseudorandom numbers. We can import it like this:\n```python\nimport random\n```\n\nThe `random` module provides a function called `choice` that chooses an element from a list at random, with every element having the same probability of being chosen:\n```python\nt = [1, 2, 3]\nrandom.choice(t)\n```\n\nIf we want to choose words with different \"weights\", so that some are chosen more often than others, we can use the `choices` function with weights:\n```python\nwords = list(word_counter)\nweights = word_counter.values()\nrandom_words = random.choices(words, weights=weights, k=6)\n```\n\nThe result is a list of strings that we can join into something that's looks more like a sentence.",
        "source": "book"
    },
    {
        "name": "Bigrams and N-grams",
        "tags": [
            "bigrams",
            "n-grams",
            "text analysis"
        ],
        "summary": "Analyzing sequences of words (bigrams, trigrams, n-grams) to understand relationships between consecutive words in text.",
        "content": "Instead of looking at one word at a time, now we'll look at sequences of two words, which are called **bigrams**. A sequence of three words is called a **trigram**, and a sequence with some unspecified number of words is called an **n-gram**.\n\nLet's write a program that finds all of the bigrams in the book and the number of times each one appears. To store the results, we'll use a dictionary where:\n\n* The keys are tuples of strings that represent bigrams, and\n* The values are integers that represent frequencies.\n\nThe following function takes a list of two strings as a parameter and counts the bigram:\n```python\ndef count_bigram(bigram):\n    key = tuple(bigram)\n    if key not in bigram_counter:\n        bigram_counter[key] = 1\n    else:\n        bigram_counter[key] += 1\n```\n\nTo keep track of pairs of consecutive words, we'll use a list called `window`:\n```python\ndef process_word(word):\n    window.append(word)\n\n    if len(window) == 2:\n        count_bigram(window)\n        window.pop(0)\n```\n\nThis approach slides a window over the text, processing each pair of consecutive words as a bigram.",
        "source": "book"
    },
    {
        "name": "Markov Analysis",
        "tags": [
            "markov chain",
            "successor mapping",
            "text generation"
        ],
        "summary": "Using Markov chain analysis to map each word to its possible successors, enabling text generation that preserves the statistical relationships of the original text.",
        "content": "We can do better with Markov chain text analysis, which computes, for each word in a text, the list of words that come next. To store the results, we'll use a dictionary that maps from each word to the list of words that follow it.\n\nThe following function encapsulates the process of adding bigrams to the successor map:\n```python\ndef add_bigram(bigram):\n    first, second = bigram\n\n    if first not in successor_map:\n        successor_map[first] = [second]\n    else:\n        successor_map[first].append(second)\n```\n\nIf the same bigram appears more that once, the second word is added to the list more than once. In this way, `successor_map` keeps track of how many times each successor appears.\n\nWe use a similar window-based approach to process the text:\n```python\ndef process_word_bigram(word):\n    window.append(word)\n\n    if len(window) == 2:\n        add_bigram(window)\n        window.pop(0)\n```\n\nThis analysis creates a mapping that shows which words can follow each word in the original text.",
        "source": "book"
    },
    {
        "name": "Markov Text Generation",
        "tags": [
            "text generation",
            "markov chain",
            "random walk"
        ],
        "summary": "Generating new text using Markov chain analysis by starting with a word and repeatedly choosing random successors based on the original text's patterns.",
        "content": "We can use the results from Markov analysis to generate new text with the same relationships between consecutive words as in the original. Here's how it works:\n\n* Starting with any word that appears in the text, we look up its possible successors and choose one at random.\n* Then, using the chosen word, we look up its possible successors, and choose one at random.\n\nWe can repeat this process to generate as many words as we want. Here's an example:\n```python\nword = 'although'\nsuccessors = successor_map[word]\nword = random.choice(successors)\n```\n\nIf the same word appears more than once in the list, it is more likely to be selected.\n\nRepeating these steps, we can use a loop to generate a longer series:\n```python\nfor i in range(10):\n    successors = successor_map[word]\n    word = random.choice(successors)\n    print(word, end=' ')\n```\n\nThe result sounds more like a real sentence, but it still doesn't make much sense. We can do better using more than one word as a key in `successor_map`.",
        "source": "book"
    },
    {
        "name": "Debugging Strategies",
        "tags": [
            "debugging",
            "problem solving",
            "rubber duck"
        ],
        "summary": "Comprehensive debugging strategies including reading code, running experiments, thinking systematically, and using rubber duck debugging.",
        "content": "At this point we are writing more substantial programs, and you might find that you are spending more time debugging. If you are stuck on a difficult bug, here are a few things to try:\n\n* **Reading**: Examine your code, read it back to yourself, and check that it says what you meant to say.\n\n* **Running**: Experiment by making changes and running different versions. Often if you display the right thing at the right place in the program, the problem becomes obvious.\n\n* **Ruminating**: Take some time to think! What kind of error is it: syntax, runtime, or semantic? What information can you get from the error messages?\n\n* **Rubberducking**: If you explain the problem to someone else, you sometimes find the answer before you finish asking the question. Often you don't need the other person; you could just talk to a rubber duck. This is called **rubber duck debugging**.\n\n* **Retreating**: At some point, the best thing to do is back up -- undoing recent changes -- until you get to a program that works.\n\n* **Resting**: If you give your brain a break, sometime it will find the problem for you.\n\nFinding a hard bug requires reading, running, ruminating, retreating, and sometimes resting. If you get stuck on one of these activities, try the others.",
        "source": "book"
    },
    {
        "name": "Text Analysis Glossary",
        "tags": [
            "glossary",
            "definitions",
            "terminology"
        ],
        "summary": "Key terms related to text analysis, Markov chains, and debugging techniques.",
        "content": "**default value:** The value assigned to a parameter if no argument is provided.\n\n**override:** To replace a default value with an argument.\n\n**deterministic:** A deterministic program does the same thing each time it runs, given the same inputs.\n\n**pseudorandom:** A pseudorandom sequence of numbers appears to be random, but is generated by a deterministic program.\n\n**bigram:** A sequence of two elements, often words.\n\n**trigram:** A sequence of three elements.\n\n**n-gram:** A sequence of an unspecified number of elements.\n\n**rubber duck debugging:** A way of debugging by explaining a problem aloud to an inanimate object.",
        "source": "book"
    },
    {
        "name": "Files and Databases",
        "tags": [
            "persistent",
            "ephemeral",
            "files",
            "databases"
        ],
        "summary": "Comparison between ephemeral programs that run briefly and lose data, and persistent programs that run long-term and store data in files or databases.",
        "content": "Most of the programs we have seen so far are **ephemeral** in the sense that they run for a short time and produce output, but when they end, their data disappears. Each time you run an ephemeral program, it starts with a clean slate.\n\nOther programs are **persistent**: they run for a long time (or all the time); they keep at least some of their data in long-term storage; and if they shut down and restart, they pick up where they left off.\n\nA simple way for programs to maintain their data is by reading and writing text files. A more versatile alternative is to store data in a database. Databases are specialized files that can be read and written more efficiently than text files, and they provide additional capabilities.",
        "source": "book"
    },
    {
        "name": "Filenames and Paths",
        "tags": [
            "directories",
            "paths",
            "os module",
            "file system"
        ],
        "summary": "Working with file names, directories, and paths using the os module, including relative and absolute paths.",
        "content": "Files are organized into **directories**, also called \"folders\". Every running program has a **current working directory**, which is the default directory for most operations. For example, when you open a file, Python looks for it in the current working directory.\n\nThe `os` module provides functions for working with files and directories (\"os\" stands for \"operating system\"). It provides a function called `getcwd` that gets the name of the current working directory.\n\nA string like `'/home/dinsdale'` that identifies a file or directory is called a **path**. A simple filename like `'memo.txt'` is also considered a path, but it is a **relative path** because it specifies a file name relative to the current directory. A path that begins with `/` does not depend on the current directory -- it is called an **absolute path**.\n\nKey functions:\n- `os.getcwd()` - gets current working directory\n- `os.path.abspath('memo.txt')` - gets absolute path\n- `os.listdir('photos')` - lists directory contents\n- `os.path.exists('photos')` - checks if path exists\n- `os.path.isdir('photos')` - checks if path is directory\n- `os.path.isfile('photos/notes.txt')` - checks if path is file\n- `os.path.join('photos', 'jan-2023', 'photo1.jpg')` - joins paths with correct separator",
        "source": "book"
    },
    {
        "name": "f-strings",
        "tags": [
            "string formatting",
            "f-strings",
            "output"
        ],
        "summary": "Using f-strings to format strings with embedded expressions for writing data to files.",
        "content": "One way for programs to store data is to write it to a text file. To write a combination of strings and other values, we can use an **f-string**, which is a string that has the letter `f` before the opening quotation mark, and contains one or more Python expressions in curly braces.\n\nExamples:\n```python\nf'I have spotted {num_camels} camels'\nf'In {num_years} years I have spotted {num_camels} camels'\nline = f'In {round(num_years * 12)} months I have spotted {num_camels} camels'\n```\n\nThe result is a string where the expression has been evaluated and replaced with the result. There can be more than one expression, and the expressions can contain operators and function calls.\n\nIn an f-string, an expression in curly brace is converted to a string, so you can include lists, dictionaries, and other types.\n\nIf a f-string contains an invalid expression, the result is an error.",
        "source": "book"
    },
    {
        "name": "YAML",
        "tags": [
            "serialization",
            "configuration",
            "YAML",
            "data storage"
        ],
        "summary": "Using YAML format for storing configuration data and serializing Python objects.",
        "content": "One of the reasons programs read and write files is to store **configuration data**, which is information that specifies what the program should do and how.\n\nThe `yaml` module provides functions to work with YAML files, which are text files formatted to be easy for humans *and* programs to read and write.\n\nExample usage:\n```python\nimport yaml\n\nconfig_filename = 'config.yaml'\nwriter = open(config_filename, 'w')\nyaml.dump(config, writer)\nwriter.close()\n\n# Reading back\nreader = open(config_filename)\nconfig_readback = yaml.safe_load(reader)\n```\n\nConverting an object like a dictionary to a string is called **serialization**. Converting the string back to an object is called **deserialization**. If you serialize and then deserialize an object, the result should be equivalent to the original.",
        "source": "book"
    },
    {
        "name": "Shelve Module",
        "tags": [
            "databases",
            "key-value stores",
            "shelve",
            "persistent storage"
        ],
        "summary": "Using the shelve module to create and work with key-value store databases.",
        "content": "A **database** is a file that is organized for storing data. Some databases are organized like a table with rows and columns of information. Others are organized like a dictionary that maps from keys to values; they are sometimes called **key-value stores**.\n\nThe `shelve` module provides functions for creating and updating a key-value store called a \"shelf\".\n\nExample usage:\n```python\nimport shelve\n\ndb_file = os.path.join(config['data_dir'], 'captions')\ndb = shelve.open(db_file, 'c')\n\n# Adding items\nkey = 'jan-2023/photo1.jpg'\ndb[key] = 'Cat nose'\n\n# Retrieving items\nvalue = db[key]\n\n# Dictionary-like operations\nlist(db.keys())\nlist(db.values())\nkey in db\n\nfor key in db:\n    print(key, ':', db[key])\n\ndb.close()\n```\n\nThe shelf object behaves in many ways like a dictionary. Some dictionary methods, like `keys`, `values` and `items`, also work with shelf objects.",
        "source": "book"
    },
    {
        "name": "Storing Data Structures in Shelve",
        "tags": [
            "shelve",
            "data structures",
            "persistent storage"
        ],
        "summary": "Storing complex data structures like lists and dictionaries in shelve databases.",
        "content": "In the previous example, the keys and values in the shelf are strings. But we can also use a shelf to contain data structures like lists and dictionaries.\n\nImportant note: When working with mutable objects in shelve, you must read the value, update it, and write it back to the shelf:\n\n```python\n# INCORRECT - this won't update the shelf\ndb[key].append(word)\n\n# CORRECT - read, update, write back\nanagram_list = db[key]\nanagram_list.append(word)\ndb[key] = anagram_list\n```\n\nThe problem is that when we look up the key, we get a list of strings, but if we modify the list of strings, it does not affect the shelf. If we want to update the shelf, we have to read the old value, update it, and then write the new value back to the shelf.",
        "source": "book"
    },
    {
        "name": "Checking for Equivalent Files",
        "tags": [
            "file comparison",
            "binary mode",
            "hashing",
            "md5"
        ],
        "summary": "Methods for comparing file contents including direct comparison and using hash functions.",
        "content": "One way to check if files contain the same data is to read the contents of both files and compare.\n\nIf the files contain images, we have to open them with mode `'rb'`, where `'r'` means we want to read the contents and `'b'` indicates **binary mode**. In binary mode, the contents are not interpreted as text -- they are treated as a sequence of bytes.\n\nExample:\n```python\npath1 = 'photos/jan-2023/photo1.jpg'\ndata1 = open(path1, 'rb').read()\n# data1 is a bytes object\n```\n\nAn alternative is to use a **hash function**, which takes the contents of a file and computes a **digest**, which is usually a large integer. If two files contain the same data, they will have the same digest. If two files differ, they will *almost always* have different digests.\n\nThe `hashlib` module provides several hash functions - the one we'll use is called `md5`.\n\nExample:\n```python\nimport hashlib\n\ndef md5_digest(filename):\n    data = open(filename, 'rb').read()\n    md5_hash = hashlib.md5()\n    md5_hash.update(data)\n    digest = md5_hash.hexdigest()\n    return digest\n```",
        "source": "book"
    },
    {
        "name": "Walking Directories",
        "tags": [
            "directory traversal",
            "recursion",
            "file system"
        ],
        "summary": "Recursively traversing directories to find and process files.",
        "content": "The following function takes as an argument the directory we want to search. It uses `listdir` to loop through the contents of the directory. When it finds a file, it prints its complete path. When it finds a directory, it calls itself recursively to search the subdirectory.\n\n```python\ndef walk(dirname):\n    for name in os.listdir(dirname):\n        path = os.path.join(dirname, name)\n\n        if os.path.isfile(path):\n            print(path)\n        elif os.path.isdir(path):\n            walk(path)\n```\n\nThe order of the results depends on details of the operating system.",
        "source": "book"
    },
    {
        "name": "Debugging File Operations",
        "tags": [
            "debugging",
            "whitespace",
            "file handling"
        ],
        "summary": "Techniques for debugging file operations, particularly issues with whitespace and cross-platform compatibility.",
        "content": "When you are reading and writing files, you might run into problems with whitespace. These errors can be hard to debug because whitespace characters are normally invisible.\n\nThe built-in function `repr` can help. It takes any object as an argument and returns a string representation of the object. For strings, it represents whitespace characters with backslash sequences.\n\nExample:\n```python\ns = '1 2\\t 3\\n 4'\nprint(s)  # Shows: 1 2  3\n          # 4\nprint(repr(s))  # Shows: '1 2\\t 3\\n 4'\n```\n\nOne other problem you might run into is that different systems use different characters to indicate the end of a line. Some systems use a newline, represented `\\n`. Others use a return character, represented `\\r`. Some use both.\n\nFile name capitalization is another issue you might encounter if you work with different operating systems. In macOS and UNIX, file names can contain lowercase and uppercase letters, digits, and most symbols. But many Windows applications ignore the difference between lowercase and uppercase letters, and several symbols that are allowed in macOS and UNIX are not allowed in Windows.",
        "source": "book"
    },
    {
        "name": "Object-Oriented Programming Introduction",
        "tags": [
            "OOP",
            "classes",
            "objects",
            "programming paradigms"
        ],
        "summary": "Introduction to object-oriented programming using programmer-defined types to organize both code and data.",
        "content": "At this point you know how to use functions to organize code and how to use built-in types to organize data. The next step is **object-oriented programming**, which uses programmer-defined types to organize both code and data.\n\nObject-oriented programming is a big topic, so we will proceed gradually. In this chapter, we'll start with code that is not idiomatic -- that is, it is not the kind of code experienced programmers write -- but it is a good place to start. In the next two chapters, we will use additional features to write more idiomatic code.",
        "source": "book"
    },
    {
        "name": "Programmer-Defined Types",
        "tags": [
            "classes",
            "class objects",
            "instantiation",
            "instances"
        ],
        "summary": "Creating custom types using classes, class objects, and instantiating objects from classes.",
        "content": "We have used many of Python's built-in types -- now we will define a new type. As a first example, we'll create a type called `Time` that represents a time of day. A programmer-defined type is also called a **class**. A class definition looks like this:\n\n```python\nclass Time:\n    \"\"\"Represents a time of day.\"\"\"\n```\n\nThe header indicates that the new class is called `Time`. The body is a docstring that explains what the class is for. Defining a class creates a **class object**.\n\nThe class object is like a factory for creating objects. To create a `Time` object, you call `Time` as if it were a function.\n\n```python\nlunch = Time()\n```\n\nThe result is a new object whose type is `__main__.Time`, where `__main__` is the name of the module where `Time` is defined.\n\nWhen you print an object, Python tells you what type it is and where it is stored in memory (the prefix `0x` means that the following number is in hexadecimal).\n\nCreating a new object is called **instantiation**, and the object is an **instance** of the class.",
        "source": "book"
    },
    {
        "name": "Attributes",
        "tags": [
            "attributes",
            "dot notation",
            "object diagram"
        ],
        "summary": "Adding variables to objects using attributes and accessing them with dot notation.",
        "content": "An object can contain variables, which are called **attributes** and pronounced with the emphasis on the first syllable, like \"AT-trib-ute\", rather than the second syllable, like \"a-TRIB-ute\". We can create attributes using dot notation.\n\n```python\nlunch.hour = 11\nlunch.minute = 59\nlunch.second = 1\n```\n\nThis example creates attributes called `hour`, `minute`, and `second`, which contain the hours, minutes, and seconds of the time `11:59:01`.\n\nThe variable `lunch` refers to a `Time` object, which contains three attributes. Each attribute refers to an integer. A state diagram like this -- which shows an object and its attributes -- is called an **object diagram**.\n\nYou can read the value of an attribute using the dot operator.\n\n```python\nlunch.hour\n```\n\nYou can use an attribute as part of any expression.\n\n```python\ntotal_minutes = lunch.hour * 60 + lunch.minute\n```\n\nAnd you can use the dot operator in an expression in an f-string.\n\n```python\nf'{lunch.hour}:{lunch.minute}:{lunch.second}'\n```\n\nTo fix formatting issues, we can use **format specifiers** in f-strings:\n\n```python\nf'{lunch.hour}:{lunch.minute:02d}:{lunch.second:02d}'\n```",
        "source": "book"
    },
    {
        "name": "Objects as Return Values",
        "tags": [
            "functions",
            "return values",
            "object creation"
        ],
        "summary": "Creating functions that return objects and using them to create new instances.",
        "content": "Functions can return objects. For example, `make_time` takes parameters called `hour`, `minute`, and `second`, stores them as attributes in a `Time` object, and returns the new object.\n\n```python\ndef make_time(hour, minute, second):\n    time = Time()\n    time.hour = hour\n    time.minute = minute\n    time.second = second\n    return time\n```\n\nIt might be surprising that the parameters have the same names as the attributes, but that's a common way to write a function like this. Here's how we use `make_time` to create a `Time` object.\n\n```python\ntime = make_time(11, 59, 1)\nprint_time(time)\n```",
        "source": "book"
    },
    {
        "name": "Objects are Mutable",
        "tags": [
            "mutability",
            "modifying objects",
            "side effects"
        ],
        "summary": "Understanding that objects can be modified after creation and the implications of mutability.",
        "content": "Suppose you are going to a screening of a movie, like *Monty Python and the Holy Grail*, which starts at `9:20 PM` and runs for `92` minutes, which is one hour `32` minutes. What time will the movie end?\n\nFirst, we'll create a `Time` object that represents the start time.\n\n```python\nstart = make_time(9, 20, 0)\n```\n\nTo find the end time, we can modify the attributes of the `Time` object, adding the duration of the movie.\n\n```python\nstart.hour += 1\nstart.minute += 32\n```\n\nInside functions, when an object is passed as an argument, modifications to the object affect the original object since the parameter is an alias for the original object.",
        "source": "book"
    },
    {
        "name": "Copying Objects",
        "tags": [
            "copying",
            "copy module",
            "object identity"
        ],
        "summary": "Creating copies of objects using the copy module and understanding object identity vs equivalence.",
        "content": "The `copy` module provides a function called `copy` that can duplicate any object.\n\n```python\nfrom copy import copy\n```\n\nTo see how it works, let's start with a new `Time` object that represents the start time of the movie.\n\n```python\nstart = make_time(9, 20, 0)\nend = copy(start)\n```\n\nNow `start` and `end` contain the same data, but the `is` operator confirms that they are not the same object.\n\n```python\nstart is end  # Returns False\n```\n\nYou might expect `==` to yield `True` because the objects contain the same data. But for programmer-defined classes, the default behavior of the `==` operator is the same as the `is` operator -- it checks identity, not equivalence.\n\n```python\nstart == end  # Returns False\n```",
        "source": "book"
    },
    {
        "name": "Pure Functions",
        "tags": [
            "pure functions",
            "functional programming",
            "side effects"
        ],
        "summary": "Creating pure functions that don't modify their parameters and understanding functional programming style.",
        "content": "We can use `copy` to write pure functions that don't modify their parameters. For example, here's a function that takes a `Time` object and a duration in hours, minutes and seconds. It makes a copy of the original object, uses `increment_time` to modify the copy, and returns it.\n\n```python\ndef add_time(time, hours, minutes, seconds):\n    total = copy(time)\n    increment_time(total, hours, minutes, seconds)\n    return total\n```\n\n`add_time` is a **pure function** because it does not modify any of the objects passed to it as arguments and its only effect is to return a value.\n\nAnything that can be done with impure functions can also be done with pure functions. In fact, some programming languages only allow pure functions. Programs that use pure functions might be less error-prone, but impure functions are sometimes convenient and can be more efficient.\n\nIn general, I suggest you write pure functions whenever it is reasonable and resort to impure functions only if there is a compelling advantage. This approach might be called a **functional programming style**.",
        "source": "book"
    },
    {
        "name": "Prototype and Patch Development",
        "tags": [
            "development methodology",
            "prototyping",
            "debugging"
        ],
        "summary": "Using prototype and patch methodology for incremental program development and debugging.",
        "content": "This section demonstrates a program development plan I call **prototype and patch**. We started with a simple prototype that worked correctly for the first example. Then we tested it with more difficult examples -- when we found an error, we modified the program to fix it, like putting a patch on tire with a puncture.\n\nThis approach can be effective, especially if you don't yet have a deep understanding of the problem. But incremental corrections can generate code that is unnecessarily complicated -- since it deals with many special cases -- and unreliable -- since it is hard to know if you have found all the errors.",
        "source": "book"
    },
    {
        "name": "Design-First Development",
        "tags": [
            "development methodology",
            "planning",
            "abstraction"
        ],
        "summary": "Using design-first development with high-level insights to create more robust solutions.",
        "content": "An alternative plan is **design-first development**, which involves more planning before prototyping. In a design-first process, sometimes a high-level insight into the problem makes the programming much easier.\n\nIn this case, the insight is that we can think of a `Time` object as a three-digit number in base 60 -- also known as sexagesimal. The `second` attribute is the \"ones column\", the `minute` attribute is the \"sixties column\", and the `hour` attribute is the \"thirty-six hundreds column\". When we wrote `increment_time`, we were effectively doing addition in base 60, which is why we had to carry from one column to the next.\n\nThis observation suggests another approach to the whole problem -- we can convert `Time` objects to integers and take advantage of the fact that Python knows how to do integer arithmetic.\n\nIronically, sometimes making a problem harder -- or more general -- makes it easier, because there are fewer special cases and fewer opportunities for error.",
        "source": "book"
    },
    {
        "name": "Debugging Objects",
        "tags": [
            "debugging",
            "type checking",
            "attributes",
            "inspection"
        ],
        "summary": "Using built-in functions to inspect and debug objects and their attributes.",
        "content": "Python provides several built-in functions that are useful for testing and debugging programs that work with objects.\n\n- `type(start)` - gets the type of an object\n- `isinstance(end, Time)` - checks if an object is an instance of a particular class\n- `hasattr(start, 'hour')` - checks if an object has a particular attribute\n- `vars(start)` - gets all attributes and their values in a dictionary\n\nThese functions help with inspecting objects and understanding their structure during development and debugging.",
        "source": "book"
    },
    {
        "name": "Object-Oriented Programming Features",
        "tags": [
            "OOP",
            "methods",
            "object-oriented language"
        ],
        "summary": "Characteristics of object-oriented programming languages and how they organize computation around objects.",
        "content": "Python is an **object-oriented language** -- that is, it provides features that support object-oriented programming, which has these defining characteristics:\n\n- Most of the computation is expressed in terms of operations on objects.\n\n- Objects often represent things in the real world, and methods often correspond to the ways things in the real world interact.\n\n- Programs include class and method definitions.\n\nFor example, in the previous chapter we defined a `Time` class that corresponds to the way people record the time of day, and we defined functions that correspond to the kinds of things people do with times. But there was no explicit connection between the definition of the `Time` class and the function definitions that follow. We can make the connection explicit by rewriting a function as a **method**, which is defined inside a class definition.",
        "source": "book"
    },
    {
        "name": "Defining Methods",
        "tags": [
            "methods",
            "self parameter",
            "method syntax"
        ],
        "summary": "Converting functions to methods by moving them inside class definitions and using the self parameter.",
        "content": "In the previous chapter we defined a class named `Time` and wrote a function named `print_time` that displays a time of day.\n\n```python\nclass Time:\n    \"\"\"Represents the time of day.\"\"\"\n\ndef print_time(time):\n    s = f'{time.hour:02d}:{time.minute:02d}:{time.second:02d}'\n    print(s)\n```\n\nTo make `print_time` a method, all we have to do is move the function definition inside the class definition. Notice the change in indentation.\n\nAt the same time, we'll change the name of the parameter from `time` to `self`. This change is not necessary, but it is conventional for the first parameter of a method to be named `self`.\n\n```python\nclass Time:\n    \"\"\"Represents the time of day.\"\"\"\n\n    def print_time(self):\n        s = f'{self.hour:02d}:{self.minute:02d}:{self.second:02d}'\n        print(s)\n```\n\nThere are two ways to call this method. The first (and less common) way is to use function syntax:\n\n```python\nTime.print_time(start)\n```\n\nThe second (and more idiomatic) way is to use method syntax:\n\n```python\nstart.print_time()\n```\n\nIn method syntax, `start` is the object the method is invoked on, which is called the **receiver**, based on the analogy that invoking a method is like sending a message to an object.\n\nRegardless of the syntax, the behavior of the method is the same. The receiver is assigned to the first parameter, so inside the method, `self` refers to the same object as `start`.",
        "source": "book"
    },
    {
        "name": "Static Methods",
        "tags": [
            "static methods",
            "class methods",
            "factory methods"
        ],
        "summary": "Creating static methods that don't require an instance and can be invoked on the class itself.",
        "content": "As another example, let's consider the `int_to_time` function. This function takes `seconds` as a parameter and returns a new `Time` object. If we transform it into a method of the `Time` class, we have to invoke it on a `Time` object. But if we're trying to create a new `Time` object, what are we supposed to invoke it on?\n\nWe can solve this chicken-and-egg problem using a **static method**, which is a method that does not require an instance of the class to be invoked.\n\n```python\ndef int_to_time(seconds):\n    minute, second = divmod(seconds, 60)\n    hour, minute = divmod(minute, 60)\n    return make_time(hour, minute, second)\n```\n\nBecause it is a static method, it does not have `self` as a parameter. To invoke it, we use `Time`, which is the class object.\n\n```python\nstart = Time.int_to_time(34800)\n```\n\nStatic methods are useful for creating factory methods that create new instances of a class.",
        "source": "book"
    },
    {
        "name": "Instance Methods",
        "tags": [
            "instance methods",
            "receiver",
            "method invocation"
        ],
        "summary": "Regular methods that require an instance as receiver and operate on that instance.",
        "content": "`add_time` has `self` as a parameter because it is not a static method. It is an ordinary method -- also called an **instance method**. To invoke it, we need a `Time` instance.\n\n```python\nend = start.add_time(1, 32, 0)\n```\n\nInstance methods are the most common type of method and operate on the specific instance they are invoked on.",
        "source": "book"
    },
    {
        "name": "The __str__ Method",
        "tags": [
            "special methods",
            "string representation",
            "object conversion"
        ],
        "summary": "Using the __str__ special method to define how objects are converted to strings.",
        "content": "When you write a method, you can choose almost any name you want. However, some names have special meanings. For example, if an object has a method named `__str__`, Python uses that method to convert the object to a string.\n\n```python\ndef __str__(self):\n    s = f'{self.hour:02d}:{self.minute:02d}:{self.second:02d}'\n    return s\n```\n\nThis method is similar to `print_time`, from the previous chapter, except that it returns the string rather than printing it.\n\nYou can invoke this method in the usual way, but Python can also invoke it for you. If you use the built-in function `str` to convert a `Time` object to a string, Python uses the `__str__` method in the `Time` class.\n\n```python\nstr(end)\n```\n\nAnd it does the same if you print a `Time` object.\n\n```python\nprint(end)\n```\n\nMethods like `__str__` are called **special methods**. You can identify them because their names begin and end with two underscores.",
        "source": "book"
    },
    {
        "name": "The __init__ Method",
        "tags": [
            "initialization",
            "constructor",
            "default parameters"
        ],
        "summary": "Using the __init__ special method to initialize object attributes when creating new instances.",
        "content": "The most special of the special methods is `__init__`, so-called because it initializes the attributes of a new object. An `__init__` method for the `Time` class might look like this:\n\n```python\ndef __init__(self, hour=0, minute=0, second=0):\n    self.hour = hour\n    self.minute = minute\n    self.second = second\n```\n\nNow when we instantiate a `Time` object, Python invokes `__init__`, and passes along the arguments. So we can create an object and initialize the attributes at the same time.\n\n```python\ntime = Time(9, 40, 0)\nprint(time)\n```\n\nIn this example, the parameters are optional, so if you call `Time` with no arguments, you get the default values.\n\n```python\ntime = Time()\nprint(time)\n```\n\nIf you provide one argument, it overrides `hour`; if you provide two arguments, they override `hour` and `minute`; and if you provide three arguments, they override all three default values.\n\nWhen I write a new class, I almost always start by writing `__init__`, which makes it easier to create objects, and `__str__`, which is useful for debugging.",
        "source": "book"
    },
    {
        "name": "Operator Overloading",
        "tags": [
            "operator overloading",
            "special methods",
            "__add__"
        ],
        "summary": "Changing operator behavior for custom classes using special methods like __add__.",
        "content": "By defining other special methods, you can specify the behavior of operators on programmer-defined types. For example, if you define a method named `__add__` for the `Time` class, you can use the `+` operator on Time objects.\n\nHere is an `__add__` method:\n\n```python\ndef __add__(self, other):\n    seconds = self.time_to_int() + other.time_to_int()\n    return Time.int_to_time(seconds)\n```\n\nWe can use it like this:\n\n```python\nduration = Time(1, 32)\nend = start + duration\nprint(end)\n```\n\nThere is a lot happening when we run these three lines of code:\n\n- When we instantiate a `Time` object, the `__init__` method is invoked.\n\n- When we use the `+` operator with a `Time` object, its `__add__` method is invoked.\n\n- And when we print a `Time` object, its `__str__` method is invoked.\n\nChanging the behavior of an operator so that it works with programmer-defined types is called **operator overloading**. For every operator, like `+`, there is a corresponding special method, like `__add__`.",
        "source": "book"
    },
    {
        "name": "Debugging with Invariants",
        "tags": [
            "debugging",
            "invariants",
            "assert",
            "validation"
        ],
        "summary": "Using invariants and assert statements to validate object state and detect errors.",
        "content": "A `Time` object is valid if the values of `minute` and `second` are between `0` and `60` -- including `0` but not `60` -- and if `hour` is positive. Also, `hour` and `minute` should be integer values, but we might allow `second` to have a fraction part. Requirements like these are called **invariants** because they should always be true. To put it a different way, if they are not true, something has gone wrong.\n\nWriting code to check invariants can help detect errors and find their causes. For example, you might have a method like `is_valid` that takes a Time object and returns `False` if it violates an invariant.\n\n```python\ndef is_valid(self):\n    if self.hour < 0 or self.minute < 0 or self.second < 0:\n        return False\n    if self.minute >= 60 or self.second >= 60:\n        return False\n    if not isinstance(self.hour, int):\n        return False\n    if not isinstance(self.minute, int):\n        return False\n    return True\n```\n\nThen, at the beginning of each method you can check the arguments to make sure they are valid.\n\n```python\ndef is_after(self, other):\n    assert self.is_valid(), 'self is not a valid Time'\n    assert other.is_valid(), 'self is not a valid Time'\n    return self.time_to_int() > other.time_to_int()\n```\n\nThe `assert` statement evaluates the expression that follows. If the result is `True`, it does nothing; if the result is `False`, it causes an `AssertionError`.\n\n`assert` statements are useful because they distinguish code that deals with normal conditions from code that checks for errors.",
        "source": "book"
    },
    {
        "name": "Classes and Objects",
        "tags": [
            "object-oriented programming",
            "classes",
            "objects"
        ],
        "summary": "Introduction to object-oriented programming concepts including defining classes, creating objects, and using methods to create, modify, and perform computations with geometric objects.",
        "content": "At this point we have defined classes and created objects that represent the time of day and the day of the year. And we've defined methods that create, modify, and perform computations with these objects.\n\nIn this chapter we'll continue our tour of object-oriented programming (OOP) by defining classes that represent geometric objects, including points, lines, rectangles, and circles. We'll write methods that create and modify these objects, and we'll use the `jupyturtle` module to draw them.\n\nI'll use these classes to demonstrate OOP topics including object identity and equivalence, shallow and deep copying, and polymorphism.",
        "source": "book"
    },
    {
        "name": "Creating a Point",
        "tags": [
            "point",
            "coordinates",
            "class definition"
        ],
        "summary": "Defining a Point class to represent locations in 2D space using x and y coordinates, with methods for initialization, string representation, translation, and copying.",
        "content": "In computer graphics a location on the screen is often represented using a pair of coordinates in an `x`-`y` plane. By convention, the point `(0, 0)` usually represents the upper-left corner of the screen, and  `(x, y)` represents the point `x` units to the right and `y` units down from the origin. Compared to the Cartesian coordinate system you might have seen in a math class, the `y` axis is upside-down.\n\nThere are several ways we might represent a point in Python:\n\n- We can store the coordinates separately in two variables, `x` and `y`.\n- We can store the coordinates as elements in a list or tuple.\n- We can create a new type to represent points as objects.\n\nIn object-oriented programming, it would be most idiomatic to create a new type.\n\n```python\nclass Point:\n    \"\"\"Represents a point in 2-D space.\"\"\"\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f'Point({self.x}, {self.y})'\n```\n\nThe `__init__` method takes the coordinates as parameters and assigns them to attributes `x` and `y`. The `__str__` method returns a string representation of the `Point`.\n\nWe can write methods like `translate` that takes two numbers, `dx` and `dy`, and adds them to the attributes `x` and `y`:\n\n```python\ndef translate(self, dx, dy):\n    self.x += dx\n    self.y += dy\n```\n\nIf we don't want to modify an existing `Point`, we can use `copy` to copy the original object and then modify the copy, or create a `translated` method:\n\n```python\ndef translated(self, dx=0, dy=0):\n    point = copy(self)\n    point.translate(dx, dy)\n    return point\n```",
        "source": "book"
    },
    {
        "name": "Creating a Line",
        "tags": [
            "line",
            "segments",
            "drawing"
        ],
        "summary": "Defining a Line class that represents line segments between two points, with methods for drawing lines using the jupyturtle module.",
        "content": "Now let's define a class that represents the line segment between two points.\n\n```python\nclass Line:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n    def __str__(self):\n        return f'Line({self.p1}, {self.p2})'\n```\n\nWhen we call `print` and pass `line` as a parameter, `print` invokes `__str__` on `line`. The `__str__` method uses an f-string to create a string representation of the `line`. The f-string contains two expressions in curly braces, `self.p1` and `self.p2`. When those expressions are evaluated, the results are `Point` objects. Then, when they are converted to strings, the `__str__` method from the `Point` class gets invoked.\n\nTo draw lines, we'll use two new functions from the `jupyturtle` module:\n\n* `jumpto`, which takes two coordinates and moves the `Turtle` to the given location without drawing a line, and\n* `moveto`, which moves the `Turtle` from its current location to the given location, and draws a line segment between them.\n\nHere's a method that draws a `Line`:\n\n```python\ndef draw(self):\n    jumpto(self.p1.x, self.p1.y)\n    moveto(self.p2.x, self.p2.y)\n```",
        "source": "book"
    },
    {
        "name": "Equivalence and identity",
        "tags": [
            "equality",
            "identity",
            "comparison"
        ],
        "summary": "Understanding the difference between object equivalence and identity, and how to override the equality operator for custom classes.",
        "content": "Suppose we create two points with the same coordinates:\n\n```python\np1 = Point(200, 100)\np2 = Point(200, 100)\n```\n\nIf we use the `==` operator to compare them, we get the default behavior for programmer-defined types -- the result is `True` only if they are the same object, which they are not.\n\nIf we want to change that behavior, we can provide a special method called `__eq__` that defines what it means for two `Point` objects to be equal:\n\n```python\ndef __eq__(self, other):\n    return (self.x == other.x) and (self.y == other.y)\n```\n\nThis definition considers two `Points` to be equal if their attributes are equal. Now when we use the `==` operator, it invokes the `__eq__` method.\n\nBut the `is` operator still indicates that they are different objects. It's not possible to override the `is` operator -- it always checks whether the objects are identical. But for programmer-defined types, you can override the `==` operator so it checks whether the objects are equivalent. And you can define what equivalent means.",
        "source": "book"
    },
    {
        "name": "Creating a Rectangle",
        "tags": [
            "rectangle",
            "geometric objects",
            "composition"
        ],
        "summary": "Defining a Rectangle class that uses width, height, and a corner point to represent rectangles, with methods for creating points, lines, and drawing.",
        "content": "Now let's define a class that represents and draws rectangles. To keep things simple, we'll assume that the rectangles are either vertical or horizontal, not at an angle.\n\nThere are at least two possibilities for specifying the location and size of a rectangle:\n\n- You could specify the width and height of the rectangle and the location of one corner.\n- You could specify two opposing corners.\n\nHere is the class definition using the first approach:\n\n```python\nclass Rectangle:\n    \"\"\"Represents a rectangle.\n\n    attributes: width, height, corner.\n    \"\"\"\n    def __init__(self, width, height, corner):\n        self.width = width\n        self.height = height\n        self.corner = corner\n\n    def __str__(self):\n        return f'Rectangle({self.width}, {self.height}, {self.corner})'\n```\n\nTo draw a rectangle, we can create methods to make four `Point` objects to represent the corners and four `Line` objects to represent the sides:\n\n```python\ndef make_points(self):\n    p1 = self.corner\n    p2 = p1.translated(self.width, 0)\n    p3 = p2.translated(0, self.height)\n    p4 = p3.translated(-self.width, 0)\n    return p1, p2, p3, p4\n\ndef make_lines(self):\n    p1, p2, p3, p4 = self.make_points()\n    return Line(p1, p2), Line(p2, p3), Line(p3, p4), Line(p4, p1)\n\ndef draw(self):\n    lines = self.make_lines()\n    for line in lines:\n        line.draw()\n```",
        "source": "book"
    },
    {
        "name": "Changing rectangles",
        "tags": [
            "modification",
            "methods",
            "bugs"
        ],
        "summary": "Methods for modifying rectangles including grow and translate, with discussion of a subtle bug related to shared objects.",
        "content": "Now let's consider two methods that modify rectangles, `grow` and `translate`. We'll see that `grow` works as expected, but `translate` has a subtle bug.\n\n`grow` takes two numbers, `dwidth` and `dheight`, and adds them to the `width` and `height` attributes of the rectangle:\n\n```python\ndef grow(self, dwidth, dheight):\n    self.width += dwidth\n    self.height += dheight\n```\n\n`translate` takes two numbers, `dx` and `dy`, and moves the rectangle the given distances in the `x` and `y` directions:\n\n```python\ndef translate(self, dx, dy):\n    self.corner.translate(dx, dy)\n```\n\nWhen we use `copy` to duplicate a rectangle and then translate the copy, both rectangles appear to move. This happens because when we use `copy` to duplicate a rectangle, it copies the `Rectangle` object but not the `Point` object it contains. So the rectangles are different objects, as intended, but their `corner` attributes refer to the same object.",
        "source": "book"
    },
    {
        "name": "Deep copy",
        "tags": [
            "copying",
            "shallow copy",
            "deep copy"
        ],
        "summary": "Understanding the difference between shallow and deep copying, and how to use deepcopy to create completely independent copies of nested objects.",
        "content": "When we use `copy` to duplicate an object, it copies the object but not the objects it contains. As a result, changing the `width` or `height` of one `Rectangle` does not affect the other, but changing the attributes of the shared `Point` affects both! This behavior is confusing and error-prone.\n\nWhat `copy` does is called a **shallow copy** because it copies the object but not the objects it contains.\n\nFortunately, the `copy` module provides another function, called `deepcopy`, that copies not only the object but also the objects it refers to, and the objects *they* refer to, and so on. This operation is called a **deep copy**.\n\n```python\nfrom copy import deepcopy\n\nbox4 = deepcopy(box3)\n```\n\nWith deep copy, we can confirm that the two `Rectangle` objects refer to different `Point` objects:\n\n```python\nbox3.corner is box4.corner  # Returns False\n```\n\nBecause `box3` and `box4` are completely separate objects, we can modify one without affecting the other.",
        "source": "book"
    },
    {
        "name": "Polymorphism",
        "tags": [
            "polymorphism",
            "methods",
            "multiple types"
        ],
        "summary": "The concept of polymorphism where different types can provide the same methods, allowing uniform treatment of different objects.",
        "content": "In the previous example, we invoked the `draw` method on two `Line` objects and two `Rectangle` objects. We can do the same thing more concisely by making a list of objects:\n\n```python\nshapes = [line1, line2, box3, box4]\n```\n\nThe elements of this list are different types, but they all provide a `draw` method, so we can loop through the list and invoke `draw` on each one:\n\n```python\nfor shape in shapes:\n    shape.draw()\n```\n\nThe first and second time through the loop, `shape` refers to a `Line` object, so when `draw` is invoked, the method that runs is the one defined in the `Line` class.\n\nThe third and fourth time through the loop, `shape` refers to a `Rectangle` object, so when `draw` is invoked, the method that runs is the one defined in the `Rectangle` class.\n\nIn a sense, each object knows how to draw itself. This feature is called **polymorphism**. The word comes from Greek roots that mean \"many shaped\". In object-oriented programming, polymorphism is the ability of different types to provide the same methods, which makes it possible to perform many computations -- like drawing shapes -- by invoking the same method on different types of objects.",
        "source": "book"
    },
    {
        "name": "Debugging",
        "tags": [
            "debugging",
            "shared objects",
            "immutability"
        ],
        "summary": "Strategies for avoiding bugs related to shared objects, including using deep copy and avoiding object modification.",
        "content": "In this chapter, we ran into a subtle bug that happened because we created a `Point` that was shared by two `Rectangle` objects, and then we modified the `Point`. In general, there are two ways to avoid problems like this: you can avoid sharing objects or you can avoid modifying them.\n\nTo avoid sharing objects, you can use deep copy, as we did in this chapter.\n\nTo avoid modifying objects, consider replacing impure functions like `translate` with pure functions like `translated`. For example, here's a version of `translated` that creates a new `Point` and never modifies its attributes:\n\n```python\ndef translated(self, dx=0, dy=0):\n    x = self.x + dx\n    y = self.y + dy\n    return Point(x, y)\n```\n\nPython provides features that make it easier to avoid modifying objects. They are beyond the scope of this book, but if you are curious, ask a virtual assistant, \"How do I make a Python object immutable?\"\n\nCreating a new object takes more time than modifying an existing one, but the difference seldom matters in practice. Programs that avoid shared objects and impure functions are often easier to develop, test, and debug -- and the best kind of debugging is the kind you don't have to do.",
        "source": "book"
    },
    {
        "name": "Glossary",
        "tags": [
            "definitions",
            "terminology"
        ],
        "summary": "Key terms and definitions from the chapter on classes and objects.",
        "content": "**shallow copy:** A copy operation that does not copy nested objects.\n\n**deep copy:** A copy operation that also copies nested objects.\n\n**polymorphism:** The ability of a method or operator to work with multiple types of objects.",
        "source": "book"
    },
    {
        "name": "Inheritance",
        "tags": [
            "inheritance",
            "object-oriented programming",
            "classes"
        ],
        "summary": "Introduction to inheritance as a key feature of object-oriented programming that allows creating new classes as modified versions of existing classes.",
        "content": "The language feature most often associated with object-oriented programming is **inheritance**. Inheritance is the ability to define a new class that is a modified version of an existing class. In this chapter I demonstrate inheritance using classes that represent playing cards, decks of cards, and poker hands.",
        "source": "book"
    },
    {
        "name": "Representing cards",
        "tags": [
            "encoding",
            "class variables",
            "data representation"
        ],
        "summary": "Using integer encoding to represent playing card suits and ranks for easier comparison, with class variables to store string representations.",
        "content": "There are 52 playing cards in a standard deck -- each of them belongs to one of four suits and one of thirteen ranks. The suits are Spades, Hearts, Diamonds, and Clubs. The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.\n\nAn alternative to using strings is to use integers to **encode** the ranks and suits. In this context, \"encode\" means that we are going to define a mapping between numbers and suits, or between numbers and ranks.\n\nFor example, this table shows the suits and the corresponding integer codes:\n\n| Suit | Code |\n| --- | --- |\n|  Spades     |   3  |\n|  Hearts     |   2  |\n|  Diamonds   |   1  |\n|  Clubs      |   0  |\n\nTo encode the ranks, we'll use the integer `2` to represent the rank `2`, `3` to represent `3`, and so on up to `10`. The face cards are encoded as Jack=11, Queen=12, King=13, and Ace can be either 1 or 14.\n\nTo represent these encodings, we will use two lists of strings as **class variables**, which are variables defined inside a class definition, but not inside a method.\n\n```python\nclass Card:\n    \"\"\"Represents a standard playing card.\"\"\"\n\n    suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']\n    rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7',\n                  '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']\n```\n\nThe first element of `rank_names` is `None` because there is no card with rank zero. By including `None` as a place-keeper, we get a list with the nice property that the index `2` maps to the string `'2'`, and so on.",
        "source": "book"
    },
    {
        "name": "Card attributes",
        "tags": [
            "attributes",
            "initialization",
            "instance variables"
        ],
        "summary": "Defining Card class with suit and rank attributes and initialization method.",
        "content": "Here's an `__init__` method for the `Card` class -- it takes `suit` and `rank` as parameters and assigns them to attributes with the same names.\n\n```python\ndef __init__(self, suit, rank):\n    self.suit = suit\n    self.rank = rank\n```\n\nClass variables are associated with the class, rather than an instance of the class, so we can access them using the class name like `Card.suit_names`. It is also legal to use the instance to access the class variables, but using the class makes it clearer that they are class variables, not attributes.",
        "source": "book"
    },
    {
        "name": "Printing cards",
        "tags": [
            "string representation",
            "__str__",
            "formatting"
        ],
        "summary": "Creating a human-readable string representation of Card objects using the __str__ method.",
        "content": "Here's a `__str__` method for `Card` objects:\n\n```python\ndef __str__(self):\n    rank_name = Card.rank_names[self.rank]\n    suit_name = Card.suit_names[self.suit]\n    return f'{rank_name} of {suit_name}'\n```\n\nWhen we print a `Card`, Python calls the `__str__` method to get a human-readable representation of the card.\n\nEvery `Card` instance has its own `suit` and `rank` attributes, but there is only one `Card` class object, and only one copy of the class variables `suit_names` and `rank_names`.",
        "source": "book"
    },
    {
        "name": "Comparing cards",
        "tags": [
            "comparison",
            "equality",
            "ordering",
            "special methods"
        ],
        "summary": "Implementing comparison operations for Card objects using special methods like __eq__, __lt__, and __le__.",
        "content": "If we use the `==` operator to compare two Card objects with the same suit and rank, it checks whether they refer to the same object by default. We can change this behavior by defining the special method `__eq__`:\n\n```python\ndef __eq__(self, other):\n    return self.suit == other.suit and self.rank == other.rank\n```\n\n`__eq__` takes two `Card` objects as parameters and returns `True` if they have the same suit and rank, even if they are not the same object. In other words, it checks whether they are equivalent, even if they are not identical.\n\nIf we use the `!=` operator, Python invokes a special method called `__ne__`, if it exists. Otherwise it invokes `__eq__` and inverts the result.\n\nTo change the behavior of the `<` operator, we can define a special method called `__lt__`. For the sake of this example, let's assume that suit is more important than rank -- so all Spades outrank all Hearts, which outrank all Diamonds, and so on. If two cards have the same suit, the one with the higher rank wins.\n\nWe can implement this logic using a helper method:\n\n```python\ndef to_tuple(self):\n    return (self.suit, self.rank)\n\ndef __lt__(self, other):\n    return self.to_tuple() < other.to_tuple()\n```\n\nTuple comparison compares the first elements from each tuple, which represent the suits. If they are the same, it compares the second elements, which represent the ranks.\n\nIf we use the `>` operator, it invokes a special method called `__gt__`, if it exists. Otherwise it invokes `__lt__` with the arguments in the opposite order.\n\nFor the `<=` operator, we can define `__le__`:\n\n```python\ndef __le__(self, other):\n    return self.to_tuple() <= other.to_tuple()\n```\n\nIf we use the `>=` operator, it uses `__ge__` if it exists. Otherwise, it invokes `__le__` with the arguments in the opposite order.\n\nAs we have defined them, these methods are complete in the sense that we can compare any two `Card` objects, and consistent in the sense that results from different operators don't contradict each other. With these two properties, we can say that `Card` objects are **totally ordered**. And that means they can be sorted.",
        "source": "book"
    },
    {
        "name": "Decks",
        "tags": [
            "collections",
            "composition",
            "static methods"
        ],
        "summary": "Creating a Deck class that contains a collection of Card objects with methods for card manipulation.",
        "content": "Now that we have objects that represent cards, let's define objects that represent decks. The following is a class definition for `Deck` with an `__init__` method that takes a list of `Card` objects as a parameter and assigns it to an attribute called `cards`.\n\n```python\nclass Deck:\n    def __init__(self, cards):\n        self.cards = cards\n```\n\nTo create a list that contains the 52 cards in a standard deck, we'll use the following static method:\n\n```python\ndef make_cards():\n    cards = []\n    for suit in range(4):\n        for rank in range(2, 15):\n            card = Card(suit, rank)\n            cards.append(card)\n    return cards\n```\n\nIn `make_cards`, the outer loop enumerates the suits from `0` to `3`. The inner loop enumerates the ranks from `2` to `14` -- where `14` represents an Ace that outranks a King.",
        "source": "book"
    },
    {
        "name": "Printing the deck",
        "tags": [
            "string representation",
            "efficiency",
            "join"
        ],
        "summary": "Creating an efficient string representation for Deck objects using join for better performance.",
        "content": "Here is a `__str__` method for `Deck`:\n\n```python\ndef __str__(self):\n    res = []\n    for card in self.cards:\n        res.append(str(card))\n    return '\\n'.join(res)\n```\n\nThis method demonstrates an efficient way to accumulate a large string -- building a list of strings and then using the string method `join`.",
        "source": "book"
    },
    {
        "name": "Add, remove, shuffle and sort",
        "tags": [
            "methods",
            "delegation",
            "list operations"
        ],
        "summary": "Implementing deck operations including taking cards, putting cards back, shuffling, and sorting.",
        "content": "To deal cards, we would like a method that removes a card from the deck and returns it. The list method `pop` provides a convenient way to do that:\n\n```python\ndef take_card(self):\n    return self.cards.pop()\n```\n\nTo add a card, we can use the list method `append`:\n\n```python\ndef put_card(self, card):\n    self.cards.append(card)\n```\n\nTo shuffle the deck, we can use the `shuffle` function from the `random` module:\n\n```python\ndef shuffle(self):\n    random.shuffle(self.cards)\n```\n\nTo sort the cards, we can use the list method `sort`, which sorts the elements \"in place\":\n\n```python\ndef sort(self):\n    self.cards.sort()\n```\n\nWhen we invoke `sort`, it uses the `__lt__` method to compare cards. In this example, `Deck.sort` doesn't do anything other than invoke `list.sort`. Passing along responsibility like this is called **delegation**.",
        "source": "book"
    },
    {
        "name": "Parents and children",
        "tags": [
            "inheritance",
            "parent class",
            "child class",
            "Liskov substitution"
        ],
        "summary": "Understanding parent-child class relationships in inheritance and the Liskov substitution principle.",
        "content": "Inheritance is the ability to define a new class that is a modified version of an existing class. As an example, let's say we want a class to represent a \"hand\", that is, the cards held by one player.\n\n* A hand is similar to a deck -- both are made up of a collection of cards, and both require operations like adding and removing cards.\n* A hand is also different from a deck -- there are operations we want for hands that don't make sense for a deck.\n\nThis relationship between classes -- where one is a specialized version of another -- lends itself to inheritance.\n\nTo define a new class that is based on an existing class, we put the name of the existing class in parentheses:\n\n```python\nclass Hand(Deck):\n    \"\"\"Represents a hand of playing cards.\"\"\"\n```\n\nThis definition indicates that `Hand` inherits from `Deck`, which means that `Hand` objects can access methods defined in `Deck`, like `take_card` and `put_card`.\n\n`Hand` also inherits `__init__` from `Deck`, but if we define `__init__` in the `Hand` class, it overrides the one in the `Deck` class.\n\nWhen a new class inherits from an existing one, the existing one is called the **parent** and the new class is called the **child**. In general:\n\n* Instances of the child class should have all of the attributes of the parent class, but they can have additional attributes.\n* The child class should have all of the methods of the parent class, but it can have additional methods.\n* If a child class overrides a method from the parent class, the new method should take the same parameters and return a compatible result.\n\nThis set of rules is called the \"Liskov substitution principle\" after computer scientist Barbara Liskov.\n\nIf you follow these rules, any function or method designed to work with an instance of a parent class, like a `Deck`, will also work with instances of a child class, like `Hand`.",
        "source": "book"
    },
    {
        "name": "Specialization",
        "tags": [
            "specialization",
            "bridge",
            "game-specific logic"
        ],
        "summary": "Using inheritance for specialization by creating game-specific classes with additional functionality.",
        "content": "Let's make a class called `BridgeHand` that represents a hand in bridge -- a widely played card game. We'll inherit from `Hand` and add a new method called `high_card_point_count` that evaluates a hand using a \"high card point\" method, which adds up points for the high cards in the hand.\n\nHere's a class definition that contains as a class variable a dictionary that maps from card names to their point values:\n\n```python\nclass BridgeHand(Hand):\n    \"\"\"Represents a bridge hand.\"\"\"\n\n    hcp_dict = {\n        'Ace': 4,\n        'King': 3,\n        'Queen': 2,\n        'Jack': 1,\n    }\n```\n\nGiven the rank of a card, like `12`, we can use `Card.rank_names` to get the string representation of the rank, and then use `hcp_dict` to get its score.\n\n`BridgeHand` inherits the variables and methods of `Hand` and adds a class variable and a method that are specific to bridge. This way of using inheritance is called **specialization** because it defines a new class that is specialized for a particular use, like playing bridge.",
        "source": "book"
    },
    {
        "name": "Debugging",
        "tags": [
            "debugging",
            "method resolution",
            "inheritance challenges"
        ],
        "summary": "Debugging techniques for inheritance and understanding method resolution order.",
        "content": "Inheritance is a useful feature. Some programs that would be repetitive without inheritance can be written more concisely with it. Also, inheritance can facilitate code reuse, since you can customize the behavior of a parent class without having to modify it. In some cases, the inheritance structure reflects the natural structure of the problem, which makes the design easier to understand.\n\nOn the other hand, inheritance can make programs difficult to read. When a method is invoked, it is sometimes not clear where to find its definition -- the relevant code may be spread across several modules.\n\nAny time you are unsure about the flow of execution through your program, the simplest solution is to add print statements at the beginning of the relevant methods.\n\nAs an alternative, you could use the following function, which takes an object and a method name (as a string) and returns the class that provides the definition of the method:\n\n```python\ndef find_defining_class(obj, method_name):\n    \"\"\"Find the class where the given method is defined.\"\"\"\n    for typ in type(obj).mro():\n        if method_name in vars(typ):\n            return typ\n    return f'Method {method_name} not found.'\n```\n\n`find_defining_class` uses the `mro` method to get the list of class objects (types) that will be searched for methods. \"MRO\" stands for \"method resolution order\", which is the sequence of classes Python searches to \"resolve\" a method name -- that is, to find the function object the name refers to.",
        "source": "book"
    },
    {
        "name": "Glossary",
        "tags": [
            "definitions",
            "terminology"
        ],
        "summary": "Key terms and definitions from the chapter on inheritance.",
        "content": "**inheritance:** The ability to define a new class that is a modified version of a previously defined class.\n\n**encode:** To represent one set of values using another set of values by constructing a mapping between them.\n\n**class variable:** A variable defined inside a class definition, but not inside any method.\n\n**totally ordered:** A set of objects is totally ordered if we can compare any two elements and the results are consistent.\n\n**delegation:** When one method passes responsibility to another method to do most or all of the work.\n\n**parent class:** A class that is inherited from.\n\n**child class:** A class that inherits from another class.\n\n**specialization:** A way of using inheritance to create a new class that is a specialized version of an existing class.",
        "source": "book"
    }
]